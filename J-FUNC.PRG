*********************************Presentaci¢n*********************************
? ""
? "Espa§ol..."
? ""
? "     ***** J-Func 0.01 para Clipper 5.01 ***** "
? " En esta librer°a encontrar† funciones muy £tiles"
? " y pr†cticas para su uso en Clipper 5.01"
? " Todos los derechos est†n reservados a Jean RubÇn Machuca Araya."
? " Cualquier copia de esta librer°a est† penada por la Ley."
? ""
? "English..."
? ""
? "     ***** J-Func 0.01 for Clipper 5.01 ***** "
? " In this library will find functions very useful"
? " and practics to your use in Clipper 5.01"
? " All rights are reserved to Jean RubÇn Machuca Araya."
? " Any copy of this library is punishmented by the Law."
? ""
RETURN NIL

***************************FUNCIONES PUBLICAS*********************************

**********FUNCION SCREEN***********************
*SALVA Y RESTAURA LOS SGTES. VALORES:
*MODO DE VSUALIZACION.
*MODO DE INSERCION.
*CAPSLOCK.
*NUMLOCK.
*POSICION Y ESTADO DEL CURSOR.
*PANTALLA ACTUAL.
*DIRECTORIO EN CURSO
*... Y LOS GUARDA EN UN ARRAY.
***********************************************

FUNCTION SCREEN
PARAMETERS VAR
IF VAR = NIL
PRIVATE FORMA := "/S"
ELSE
PRIVATE FORMA := "/R"
ENDIF
PRIVATE RET[12] 
RET[1] := READINSERT()
RET[2] := CAPSLOCK()
RET[3] := NUMLOCK()
RET[4] := SCROLLOCK()
RET[5] := SETCOLOR()
RET[6] := ROW()
RET[7] := COL()
RET[8] := SETCURSOR()
RET[9] := MAXROW()+1
RET[10] := MAXCOL()+1
RET[11] := DISKNAME()+":\"+CURDIR()
RET[12] := SAVESCREEN(0,0,MAXROW(),MAXCOL())
DO CASE
        CASE FORMA = "/R"
                SETMODE(VAR[9],VAR[10])
                RESTSCREEN(0,0,MAXROW(),MAXCOL(),VAR[12])
                SETCOLOR(VAR[5])
                IF ISRUTA(VAR[11])
                RUN ("CD "+VAR[11])
                ENDIF
                SETCURSOR(VAR[8])
                SETPOS(VAR[6],VAR[7])
                READINSERT(VAR[1])
                CAPSLOCK(VAR[2])
                NUMLOCK(VAR[3])
                SCROLLOCK(VAR[4])
ENDCASE
RETURN RET

**********FUNCION PASSWORD***********************
*PERMITE COMPARAR UN VALOR IMPUESTO POR EL USUARIO
*CON UN VALOR DETERMINADO EN FORMA DE CLAVE.
***********************************************

FUNCTION PASSWORD
PARAMETERS F, C, V_INI, CHRSIMB
IF EMPTY(F)
PRIVATE F := 0
ENDIF
IF EMPTY(C)
PRIVATE C := 0
ENDIF
IF V_INI == NIL
PARAERROR("PASSWORD()")
ENDIF
IF EMPTY(CHRSIMB)
PRIVATE CHRSIMB := CHR(254)
ENDIF

PRIVATE CHRSIMB := SUBSTR(CHRSIMB,1,1)
PRIVATE INK := {0,""}
DO WHILE INK[1] != 13 .AND. INK[1] != 27 .AND. INK[1] != 9
        @F,C SAY SPACE(LEN(V_INI)) COLOR EXTRAER(SETCOLOR(),",",2)
        @F,C SAY REPLICATE(CHRSIMB,LEN(ALLTRIM(INK[2]))) COLOR EXTRAER(SETCOLOR(),",",2)
        INK[1] := KEYPAUSE(0,.T.,.F.)
        DO CASE
                CASE INK[1] == 8 .OR. INK[1] == 19
                        INK[2] := STUFF(INK[2],LEN(INK[2]),1,"")
                CASE (INK[1] == 5 .OR. INK[1] == 24 .OR. INK[1] == 18 .OR. INK[1] == 3) .AND. READEXIT()
                        EXIT
                CASE INK[1] >= 48
                        IF LEN(INK[2]) < LEN(V_INI)
                                INK[2] := INK[2] + CHR(INK[1])
                        ELSE
                                IF SET(_SET_CONFIRM)
                                        INK[2] := STUFF(INK[2],LEN(INK[2]),1,CHR(INK[1]))
                                ELSE
                                        EXIT
                                ENDIF
                        ENDIF
        ENDCASE
ENDDO
@F,C SAY SPACE(LEN(V_INI))
@F,C SAY REPLICATE(CHRSIMB,LEN(ALLTRIM(INK[2])))
RETURN IF(INK[1] == 27,V_INI,INK[2])

**********FUNCION MOVER***********************
*PERMETE MOVER UN TROZO DE PANTALLA.
***********************************************

FUNCTION MOVER
PARAMETERS FSUP, COLIZQ,FINFI, COLDEREC,OPC,TIEMPO,FS_L,CI_L,FF_L,CD_L
IF FSUP = NIL .OR. COLIZQ = NIL .OR. FINFI = NIL .OR. COLDEREC = NIL 
PARAERROR("MOVER()") 
ENDIF
IF PCOUNT() >= 10
PRIVATE FSUP_L := FS_L
PRIVATE COLIZQ_L := CI_L
PRIVATE FINFI_L := FF_L
PRIVATE COLDEREC_L := CD_L
ELSE
PRIVATE FSUP_L := 0
PRIVATE COLIZQ_L := 0
PRIVATE FINFI_L := MAXROW()
PRIVATE COLDEREC_L := MAXCOL()
ENDIF
PRIVATE COLOR_ANT := SETCOLOR()
PRIVATE SMOV := SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
PRIVATE SCR_MOV
SAVE SCREEN TO SCR_MOV
SUPR_SCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
PRIVATE SCR1
SAVE SCREEN TO SCR1
RESTORE SCREEN FROM SCR_MOV
PRIVATE FI1 := FSUP
PRIVATE FI2 := FINFI
PRIVATE CO1 := COLIZQ
PRIVATE CO2 := COLDEREC
DO WHILE .T. 
IF PCOUNT() >= 6 .AND. UPPER(OPC) = "/A"
PRIVATE TECLA:=KEYPAUSE(TIEMPO,.T.,.F.)
ELSE
PRIVATE TECLA:=KEYPAUSE(0,.T.,.F.)
ENDIF
DO CASE
CASE LASTKEY() = 5 .AND. FI1 > FSUP_L  
RESTORE SCREEN FROM SCR1
PRIVATE FI1 := FI1 - 1                                      
PRIVATE FI2 := FI2 - 1                                    
CASE LASTKEY() = 24 .AND. FI2 < FINFI_L 
RESTORE SCREEN FROM SCR1
PRIVATE FI1 := FI1 + 1
PRIVATE FI2 := FI2 + 1
CASE LASTKEY() = 19 .AND. CO1 > COLIZQ_L
RESTORE SCREEN FROM SCR1
PRIVATE CO1 := CO1 - 1
PRIVATE CO2 := CO2 - 1
CASE LASTKEY() = 4 .AND.  CO2 < COLDEREC_L
RESTORE SCREEN FROM SCR1
PRIVATE CO1 := CO1 + 1
PRIVATE CO2 := CO2 + 1
CASE TECLA = 0
KEYSTUFF(5)
CASE TECLA = 27
RESTORE SCREEN FROM SCR_MOV
EXIT
CASE TECLA = 13
EXIT
ENDCASE
RESTSCREEN(FI1,CO1,FI2,CO2, SMOV)
ENDDO
SETCOLOR(COLOR_ANT)
PRIVATE DEVOLVER := {FI1,CO1,FI2,CO2}
RETURN DEVOLVER

**********FUNCION INVERTCOLOR***********************
*INVIERTE LA VARIABLE DE COLOR STANDAR
*DE LA CONSOLA Y OPCIONALMENTE INVIERTE LOS COLORES
*DE UN TROZO DE LA PANTALLA.
***********************************************

FUNCTION INVERTCOLOR
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC
SETCOLOR("I/I,I/I,I/I,I/I,I/I")

IF FSUP != NIL .AND. COLIZQ != NIL .AND. FINFI != NIL .AND. COLDEREC != NIL
        PRIVATE FI := FSUP
                DO WHILE FI <= FINFI
                PRIVATE CO := COLIZQ
                        DO WHILE CO <= COLDEREC
                        PRIVATE COLOR1 := INVERTATTR(SCREENATTR(FI,CO))
                        COLOR_IN(FI,CO,FI,CO,COLOR1) 
                        PRIVATE CO := CO + 1
                ENDDO
        PRIVATE FI := FI + 1
        ENDDO
ELSE
PARAERROR("INVERTCOLOR()")
ENDIF
RETURN NIL
        
**********FUNCION SELECTOR***********************
*PERMITE MARCAR UN TROZO DE LA PANTALLA PARA LUEGO
*TRABAJAR CON ELLA.
***********************************************

FUNCTION SELECTOR
PARAMETERS F1, C1, F2, C2, FI1, CO1, FI2, CO2, CADBOX
PRIVATE F1 := TYPE_TO(F1,0)
PRIVATE C1 := TYPE_TO(C1,0)
PRIVATE F2 := TYPE_TO(F2,0)
PRIVATE C2 := TYPE_TO(C2,0)
PRIVATE FI1 := TYPE_TO(FI1,0)
PRIVATE CO1 := TYPE_TO(CO1,0)
PRIVATE FI2 := TYPE_TO(FI2,0)
PRIVATE CO2 := TYPE_TO(CO2,0)

IF EMPTY(F1)
PRIVATE F1 := 0
ENDIF
IF EMPTY(C1)
PRIVATE C1 := 0
ENDIF
IF EMPTY(FI1)
PRIVATE FI1 := 0
ENDIF
IF EMPTY(CO1)
PRIVATE CO1 := 0
ENDIF
IF EMPTY(FI2)
PRIVATE FI2 := MAXROW()
ENDIF
IF EMPTY(CO2)
PRIVATE CO2 := MAXCOL()
ENDIF
IF EMPTY(F2)
PRIVATE F2 := 0
ENDIF
IF EMPTY(C2)
PRIVATE C2 := 0
ENDIF
IF VALTYPE(CADBOX) != "C"
PRIVATE CADBOX := "⁄-ø›Ÿ-¿›"
ENDIF

PRIVATE RC := {ROW(),COL()}, SAVESEL := SAVESCREEN(FI1,CO1,FI2,CO2), CO3 := C2, FI3 := F2

DO WHILE .T.
RESTSCREEN(FI1,CO1,FI2,CO2,SAVESEL)
DISPBOX(F1,C1,FI3,CO3,CADBOX)
SETPOS(FI3,CO3)
KEYPAUSE(0,.T.,.F.)
DO CASE
        CASE LASTKEY() = 5 .AND. FI3 > FI1
        PRIVATE FI3 := FI3 - 1

        CASE LASTKEY() = 24 .AND. FI3 < FI2
        PRIVATE FI3 := FI3 + 1

        CASE LASTKEY() = 19 .AND. CO3 > CO1
        PRIVATE CO3 := CO3 - 1

        CASE LASTKEY() = 4 .AND. CO3 < CO2
        PRIVATE CO3 := CO3 + 1

        CASE LASTKEY() = 20
        PRIVATE F1 := FI1, C1 := CO1, FI3 := FI2, CO3 := CO2

        CASE LASTKEY() = 18
        PRIVATE FI3 := FI1

        CASE LASTKEY() = 3
        PRIVATE FI3 := FI2

        CASE LASTKEY() = 1
        PRIVATE CO3 := CO1

        CASE LASTKEY() = 6
        PRIVATE CO3 := CO2

        CASE LASTKEY() = 27 .OR. LASTKEY() = 13
        EXIT

        CASE LASTKEY() = 397 .AND. F1 > FI1
        PRIVATE F1 := F1 - 1

        CASE LASTKEY() = 401 .AND. F1 < FI2
        PRIVATE F1 := F1 + 1

        CASE LASTKEY() = 26 .AND. C1 > CO1
        PRIVATE C1 := C1 - 1

        CASE LASTKEY() = 2 .AND. C1 < CO2
        PRIVATE C1 := C1 + 1

        CASE LASTKEY() = 31
        PRIVATE F1 := FI1

        CASE LASTKEY() = 30
        PRIVATE F1 := FI2

        CASE LASTKEY() = 29
        PRIVATE C1 := CO1

        CASE LASTKEY() = 23
        PRIVATE C1 := CO2

        CASE LASTKEY() = 27 .OR. LASTKEY() = 10
        EXIT

ENDCASE
ENDDO
PRIVATE COORD := {F1,C1,FI3,CO3}
        IF CO3 < C1 .OR. C1 > CO3
                PRIVATE C1 := COORD[4], CO3 := COORD[2]
        ENDIF
        IF FI3 < F1 .OR. F1 > FI3
                PRIVATE F1 := COORD[3], FI3 := COORD[1]
        ENDIF
RESTSCREEN(FI1,CO1,FI2,CO2,SAVESEL)
SETPOS(RC[1],RC[2])
        IF LASTKEY() = 27
                PRIVATE DEVSEL := NIL
        ELSE
                INVERTCOLOR(F1,C1,FI3,CO3)
                PRIVATE DEVSEL := {F1,C1,FI3,CO3}
        ENDIF
RETURN DEVSEL

**********FUNCION FIRST_UP***********************
*COLOCA MAYUSCULA AL PRIMER CARACTER ALFABêTICO
*DE UNA VARIABLE.
*************************************************

FUNCTION FIRST_UP
PARAMETERS VARI
IF VARI = NIL
PARAERROR("FIRST_UP()")
ENDIF
IF EMPTY(VARI)
RETURN VARI
ENDIF
PRIVATE VAR := VARI
PRIVATE P := 1
DO WHILE P <= LEN(VARI)
        PRIVATE CAR1 := SUBSTR(VARI,P,1)
        IF ISALPHA(CAR1)
        PRIVATE VAR := STUFF(VARI,P,1,UPPER(CAR1))
        EXIT
        ENDIF
PRIVATE P := P + 1
ENDDO
RETURN VAR

**********FUNCION COLOR_IN***********************
*CAMBIA EL COLOR STANDAR DE LA CONSOLA
*Y OPCIONALMENTE CAMBIA LOS COLORES DE UN TROZO
*DE LA PANTALLA.
***********************************************

FUNCTION COLOR_IN
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC, COLOR_AC,EFECTO
IF FSUP = NIL .OR. COLIZQ = NIL .OR. FINFI = NIL .OR. COLDEREC = NIL
PARAERROR("COLOR_IN()")
ENDIF
IF COLOR_AC = NIL
PRIVATE COLOR_AC := SETCOLOR()
ENDIF
IF EFECTO = NIL
PRIVATE EFECTO := .F.
ENDIF
IF EFECTO
        PRIVATE F := FSUP
        DO WHILE F <= FINFI
                PRIVATE C := COLIZQ
                DO WHILE C <= COLDEREC
                COL_IN(F,C,F,C)
                PRIVATE C := C + 1
                ENDDO
        PRIVATE F := F + 1
        ENDDO
ELSE
COL_IN(FSUP,COLIZQ,FINFI,COLDEREC)
ENDIF
RETURN COLOR_AC

**********FUNCION REPITCAR***********************
*DEVUELVE EL NUMERO DE VECES QUE SE REPITE UN
*CARACTER EN UNA CADENA DE CARACTERES.
***********************************************

FUNCTION REPITCAR
PARAMETERS CADENA, CARACTER

IF CADENA = NIL
PARAERROR("CARTRIM()")
ENDIF

IF CARACTER = NIL
PRIVATE CARACTER := " "
ENDIF

PRIVATE VECES := 0
DO WHILE AT(CARACTER,CADENA) != 0
        PRIVATE CADENA := STUFF(CADENA,AT(CARACTER,CADENA),LEN(CARACTER),"")
        (VECES++)
ENDDO
RETURN VECES

**********FUNCION ISCARACTER***********************
*AVERIGUA SI UN CARACTER ESTA PRESENTE EN UNA CADENA.
***************************************************

FUNCTION ISCARACTER
PARAMETERS VARIABLE, CARACTER
IF VARIABLE = NIL .OR. CARACTER = NIL
PARAERROR("ISCARACTER()")
ENDIF
RETURN AT(UPPER(CARACTER),UPPER(VARIABLE))

**********FUNCION MOVECURSOR***********************
*PERMITE MOVER EL CURSOR EN LA PANTALLA.
***********************************************

FUNCTION MOVECURSOR
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC
IF FSUP = NIL .OR. COLIZQ = NIL .OR. FINFI = NIL .OR. COLDEREC = NIL
PARAERROR("MOVECURSOR()")
ENDIF
PRIVATE FILA_AC := ROW()
PRIVATE COLUM_AC := COL()
PRIVATE FI1 := ROW()
PRIVATE CO1 := COL()
DO WHILE .T. 
KEYPAUSE(0,.T.,.F.)
DO CASE
CASE LASTKEY() = 5 .AND. FI1 > FSUP  
PRIVATE FI1 := FI1 - 1                                      
CASE LASTKEY() = 24 .AND. FI1 < FINFI 
PRIVATE FI1 := FI1 + 1
CASE LASTKEY() = 19 .AND. CO1 > COLIZQ
PRIVATE CO1 := CO1 - 1
CASE LASTKEY() = 4 .AND.  CO1 < COLDEREC
PRIVATE CO1 := CO1 + 1
CASE LASTKEY() = 18
PRIVATE FI1 := FSUP
CASE LASTKEY() = 3
PRIVATE FI1 := FINFI
CASE LASTKEY() = 1
PRIVATE CO1 := COLIZQ
CASE LASTKEY() = 6
PRIVATE CO1 := COLDEREC
CASE LASTKEY() = 27
SETPOS(FILA_AC,COLUM_AC)
RETURN NIL
CASE LASTKEY() = 13
EXIT
ENDCASE
SETPOS(FI1,CO1)
ENDDO
RETURN NIL

**********FUNCION ROW_CAR***********************
*CONVIERTE UNA FILA DE LA PANTALLA EN CADENA DE
*CARACTERES.
***********************************************

FUNCTION ROW_CAR
PARAMETERS FSUP
IF FSUP = NIL
PARAERROR("ROW_CAR()")
ENDIF
PRIVATE FILA := SAVESCREEN(FSUP,0,FSUP,MAXCOL())
PRIVATE FILA := CHARODD(FILA)
RETURN FILA

**********FUNCION COL_CAR***********************
*CONVIERTE UNA COLUMNA DE LA PANTALLA EN CADENA
*DE CARACTERES.
***********************************************

FUNCTION COL_CAR
PARAMETERS COLIZQ
IF COLIZQ = NIL
PARAERROR("COL_CAR()")
ENDIF
PRIVATE COLUM := SAVESCREEN(0,COLIZQ,MAXROW(),COLIZQ)
PRIVATE COLUM := CHARODD(COLUM)
RETURN COLUM

**********FUNCION TIMESTART***********************
*DEVUELVE LA HORA DEL SISTEMA Y MARCA UN TIEMPO
*DE PARTIDA PARA UNA EJECUSION DE TIMESTOP().
***********************************************

FUNCTION TIMESTART
PRIVATE HORA := TIME()
PRIVATE HH := EXTRAER(HORA,":",1)
PRIVATE MM := EXTRAER(HORA,":",2)
PRIVATE SS := EXTRAER(HORA,":",3)
PRIVATE HORA := HH+";"+MM+";"+SS  
RETURN HORA

**********FUNCION TIMESTOP***********************
*DEVUELVE EL TIEMPO TRANSCURRIDO DESDE UNA EJECUSION
*DE TIMESTART().
***********************************************

FUNCTION TIMESTOP
PARAMETERS HORA
IF HORA = NIL
PARAERROR("TIMESTOP()")
ENDIF
DELIMITADOR := SUBSTR(HORA,3,3)
IF DELIMITADOR != ";"
RETURN NIL
ENDIF
PRIVATE HH := SUBSTR(HORA,1,2)
PRIVATE MM := SUBSTR(HORA,4,5)
PRIVATE SS := SUBSTR(HORA,7,8)
PRIVATE HH := VAL(HH)
PRIVATE MM := VAL(MM)
PRIVATE SS := VAL(SS)
PRIVATE HORA1 := TIME()
PRIVATE HH1 := SUBSTR(HORA1,1,2)
PRIVATE MM1 := SUBSTR(HORA1,4,5)
PRIVATE SS1 := SUBSTR(HORA1,7,8)
PRIVATE HH1 := VAL(HH1)
PRIVATE MM1 := VAL(MM1)
PRIVATE SS1 := VAL(SS1)
PRIVATE HH2 := ALLTRIM(STR(HH1-HH))
PRIVATE MM2 := ALLTRIM(STR(MM1-MM))
PRIVATE SS2 := ALLTRIM(STR(SS1-SS))
IF VAL(HH2) < 10
PRIVATE HH2 := "0"+HH2
ENDIF
IF VAL(MM2) < 10
PRIVATE MM2 := "0"+MM2
ENDIF
IF VAL(SS2) < 10
PRIVATE SS2 := "0"+SS2
ENDIF
PRIVATE HORA2 := HH2+";"+MM2+";"+SS2
RETURN HORA2

*****************FUNCION DEL_VAR*********************************
*DEVUELVE EL VALOR DE LA VARIABLE EN SU ESTADO ORIGINAL ESTIMADO.
*****************************************************************

FUNCTION DEL_VAR
PARAMETERS VAR
PRIVATE TIPO := VALTYPE(VAR)
DO CASE
        CASE TIPO = "A" .OR. TIPO =  "B"
        PRIVATE VAR1 := {}
        CASE TIPO = "C" .OR. TIPO = "M"
        PRIVATE VAR1 := SPACE(LEN(VAR))
        CASE TIPO = "D"
        PRIVATE VAR1 := TYPE_TO("00/00/00",DATE())
        CASE TIPO = "L"
        PRIVATE VAR1 := .F.
        CASE TIPO = "N"
        PRIVATE VAR1 := 0
        CASE TIPO = "U"
        PRIVATE VAR1 := NIL
        OTHERWISE
        PRIVATE VAR1 := VAR
ENDCASE
RETURN VAR1        

**********FUNCION PARED***********************
*CONSTRUYE UNA PARED DE CUALQUIER PORTE EN LA
*PANTALLA.
***********************************************

FUNCTION PARED
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC, IFBOX
PRIVATE IFBOX := TYPE_TO(IFBOX,.T.)
IF PCOUNT() < 4 .AND. PCOUNT() != 0
PARAERROR("PARED()")
ENDIF
IF EMPTY(IFBOX)
PRIVATE IFBOX := .F.
ENDIF
PRIVATE ANTERIOR
SAVE SCREEN TO ANTERIOR
MURALLA()
        IF IFBOX
        @0,0,MAXROW(),MAXCOL() BOX "⁄ƒø≥Ÿƒ¿≥"
        ENDIF
IF PCOUNT() != 0
PRIVATE M := SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
CLEAR
RESTORE SCREEN FROM ANTERIOR
RESTSCREEN(FSUP,COLIZQ,FINFI,COLDEREC,M)
        IF IFBOX
        @FSUP,COLIZQ,FINFI,COLDEREC BOX "⁄ƒø≥Ÿƒ¿≥"
        ENDIF
ENDIF
RETURN NIL

**********FUNCION ISPAR***********************
*COMPRUEBA SI UN VALOR NUMêRICO ES PAR.
***********************************************

FUNCTION ISPAR
PARAMETERS NUMERO
IF NUMERO = NIL
PARAERROR("ISPAR()")
ENDIF
PRIVATE NUM := ALLTRIM(STR(NUMERO))
PRIVATE NUM1 := SUBSTR(NUM,LEN(NUM),LEN(NUM))
PRIVATE NUM1 := VAL(NUM1)
IF NUM1 = 0 .OR. NUM1 = 2 .OR. NUM1 = 4 .OR. NUM1 = 6 .OR. NUM1 = 8 
RETURN .T.
ELSE
RETURN .F.
ENDIF
RETURN NIL

**********FUNCION ISRUTA***********************
*COMPRUEBA SI LA RUTA ESPECIFICADA ES VALIDA.
***********************************************

FUNCTION ISRUTA
PARAMETERS RUTA
IF PCOUNT() < 1
PARAERROR("ISRUTA()")
ENDIF
PRIVATE ARCH := RFILE()
PRIVATE RUTA := RIGHTDEL(ALLTRIM(RUTA),"\")
PRIVATE CAR := "\"
PRIVATE HANDLE := FCREATE(RUTA+CAR+ARCH,0)
IF HANDLE = -1
        IF FERROR() = 3 .OR. FERROR() = 21 .OR. FERROR() = 15  .OR. FERROR() = 29 .OR. FERROR() = 5
        PRIVATE FER := FCLOSE(HANDLE)
        IF !FER
        FERASE(RUTA+CAR+ARCH)
        ENDIF
        RETURN .F.
        ENDIF
ELSE
FCLOSE(HANDLE)
FERASE(RUTA+CAR+ARCH)
RETURN .T.
ENDIF
FCLOSE(HANDLE)
RETURN NIL

**********FUNCION IMPRIMIR***********************
*IMPRIME UN TROZO DE LA PANTALLA.
***********************************************

FUNCTION IMPRIMIR
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC
IF PCOUNT() < 4
PARAERROR("IMPRIMIR()")
ENDIF

PRIVATE FI := FSUP
PRIVATE SDEVICE := SET(_SET_DEVICE)
IF UPPER(EXTRAER(SET(_SET_PRINTFILE),".",1)) = "LPT1" .OR. UPPER(EXTRAER(SET(_SET_PRINTFILE),".",1)) = "LPT2" .OR. UPPER(EXTRAER(SET(_SET_PRINTFILE),".",1)) = "COM1" .OR. UPPER(EXTRAER(SET(_SET_PRINTFILE),".",1)) = "COM2"
        IF !ISPRINTER()
        RETURN .F.
        ENDIF
ENDIF
SET DEVICE TO PRINT
DO WHILE FI <= FINFI
        PRIVATE CO := COLIZQ
        DO WHILE CO <= COLDEREC
        PRIVATE COLOR := COLORPOS(FI,CO)
        PRIVATE CAR := CHRPOS(FI,CO)
SETCOLOR(COLOR)
        @FI,CO SAY CAR
        PRIVATE CO := CO + 1
        ENDDO

PRIVATE FI := FI + 1
ENDDO
SET(_SET_DEVICE,SDEVICE)
RETURN .T.

**********FUNCION WINDOW_01***********************
*DIBUJA UNA VENTANA SIMPLE EN LA PANTALLA.
***********************************************

FUNCTION WINDOW_01
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC,TITULO1,PIEPAG1,OPBOX,CADENA1
IF FSUP = NIL .OR. COLIZQ = NIL .OR. FINFI = NIL .OR. COLDEREC = NIL
PARAERROR("WINDOW_01()")
ENDIF
IF TITULO1 != NIL
PRIVATE TITULO := TITULO1
ELSE
PRIVATE TITULO := ""
ENDIF
IF PIEPAG1 != NIL
PRIVATE PIEPAG := PIEPAG1
ELSE
PRIVATE PIEPAG := ""
ENDIF
PRIVATE COLOR_ANT := SETCOLOR()
COLOR_IN(FSUP+1,COLIZQ+1,FINFI+1,COLDEREC+1,"N+/N")
SET COLOR TO N/W
@FSUP,COLIZQ CLEAR TO FINFI,COLDEREC 
SET COLOR TO N+/W
@FINFI-2,COLIZQ TO FINFI-2,COLDEREC 
SET COLOR TO GR+/B
PRIVATE ETITULO:=(COLDEREC+1)-COLIZQ
@FSUP,COLIZQ SAY REPLICATE (CHR(255),ETITULO) 
@FSUP,COLIZQ SAY CHR(17)+CHR(16)+TITULO
SET COLOR TO N/W       

IF UPPER(TYPE_TO(OPBOX)) = "/BOX"
IF CADENA1 != NIL
PRIVATE CADENA := CADENA1
ELSE
PRIVATE CADENA := "⁄ƒø≥Ÿƒ¿≥"
ENDIF
@FSUP+3,COLIZQ,FINFI-5,COLDEREC BOX CADENA
ENDIF

@FINFI-1,COLIZQ SAY PIEPAG
SETCOLOR(COLOR_ANT)
RETURN NIL

**********FUNCION STR_D_M_A***********
*DEVUELVE UN VALOR DE FECHA EN FORMATO
*"DIA"+NUMERO DEL DIA+"MES"+"A•O".
**************************************

FUNCTION STR_D_M_A
PARAMETERS FECHA
IF FECHA = NIL
PARAERROR("STR_D_M_A()")
ENDIF
PRIVATE FECHA := TYPE_TO(FECHA,DATE())
PRIVATE FECHA1 := ALLTRIM(CDOW(FECHA))+" "+ALLTRIM(STR(DAY(FECHA)))+" de "+ALLTRIM(CMONTH(FECHA))+" de "+ALLTRIM(STR(YEAR(FECHA)))
RETURN FECHA1

**********FUNCION STR_M_A***********************
*DEVUELVE UN VALOR DE FECHA EN FORMATO
*"MES"+"A•O".
***********************************************

FUNCTION STR_M_A
PARAMETERS FECHA
IF FECHA = NIL
PARAERROR("STR_D_M_A()")
ENDIF
PRIVATE FECHA1 := ALLTRIM(CMONTH(FECHA))+" de "+ALLTRIM(STR(YEAR(FECHA)))
RETURN FECHA1

**********FUNCION STR_D_M***********************
*DEVUELVE UN VALOR DE FECHA EN FORMATO
*"DIA"+"MES".
***********************************************

FUNCTION STR_D_M
PARAMETERS FECHA
IF FECHA = NIL
PARAERROR("STR_D_M_A()")
ENDIF
PRIVATE FECHA1 := ALLTRIM(CDOW(FECHA))+" "+ALLTRIM(STR(DAY(FECHA)))+" de "+ALLTRIM(CMONTH(FECHA))
RETURN FECHA1

**********FUNCION ISWRITE**************************
*VERIFICA SI EL ARCHIVO ES APTO PARA SER MODIFICADO
***************************************************

FUNCTION ISWRITE
PARAMETERS ARCHIVO
IF PCOUNT() < 1
PARAERROR("ISWRITE()")
ENDIF
PRIVATE ARCHIVO := ALLTRIM(ARCHIVO)
PRIVATE HANDLE := FOPEN(ARCHIVO,1)
IF HANDLE = -1
        IF FERROR() = 8 .OR. FERROR() = 29 .OR. FERROR() = 5 
FCLOSE(HANDLE)
RETURN .F.
        ENDIF
ELSE
FCLOSE(HANDLE)
RETURN .T.
ENDIF
FCLOSE(HANDLE)
RETURN NIL

**********FUNCION FILE_NAME**************************
*SEPARA EL NOMBRE DE ARCHIVO Y SU EXTENSION
*DESDE UN NOMBRE DE ARCHIVO ESPECIFICADO.
*****************************************************

FUNCTION FILE_NAME
PARAMETERS N_FILE
IF N_FILE == NIL
PARAERROR("FILE_NAME()")
ENDIF
PRIVATE N_FILEa := ""
PRIVATE N_FILE := RIGHTDEL(UPPER(ALLTRIM(N_FILE)),".")
DO CASE
        CASE SBSTR(N_FILE,LEN(N_FILE),1) != "\" .AND. !EMPTY(AT("\",N_FILE))
                PRIVATE N_FILEa := EXTRAER(N_FILE,"\",REPITCAR(N_FILE,"\")+1)
        CASE EMPTY(AT("\",N_FILE))
                PRIVATE N_FILEa := N_FILE
ENDCASE
IF !EMPTY(SBSTR(CARTRIM(EXTRAER(N_FILEa,".",2)),1,3))
        PRIVATE N_FILEa := RIGHTDEL(SBSTR(CARTRIM(EXTRAER(N_FILEa,".",1)),1,8) + "." + SBSTR(CARTRIM(EXTRAER(N_FILEa,".",2)),1,3),".")
ELSE
        PRIVATE N_FILEa := RIGHTDEL(SBSTR(CARTRIM(N_FILEa),1,8),".")
ENDIF
RETURN N_FILEa

**********FUNCION SOLO_RUTA*****************************
*SEPARA LA RUTA DESDE UN NOMBRE DE ARCHIVO ESPECIFICADO.
********************************************************

FUNCTION SOLO_RUTA
PARAMETERS ARCHIVO
IF ARCHIVO = NIL
PARAERROR("SOLO_RUTA()")
ENDIF
PRIVATE ARCHIVO := ALLTRIM(ARCHIVO)
PRIVATE NUM := REPITCAR(ARCHIVO,"\")
PRIVATE NUM1 := 1
PRIVATE ARCHIVO1 := ""
DO WHILE NUM1 <= NUM
PRIVATE ARCHIVO2 := EXTRAER(ARCHIVO,"\",NUM1)+"\"
PRIVATE ARCHIVO1 := ARCHIVO1+ARCHIVO2
PRIVATE NUM1 := NUM1 + 1
ENDDO
PRIVATE ARCHIVO1 := SUBSTR(ARCHIVO1,1,LEN(ARCHIVO1)-1)
RETURN ARCHIVO1

**********FUNCION COPYFILE*****************************
*COPIA UN ARCHIVO Y VERIFICA EL ESTADO DE LA COPIA.
*LOS ERRORES DETECTADOS POR COPYFILE() SON LOS SGTES.:

*0 LA COPIA SE REALIZ‡ ZATISFACTORIAMENTE
*1 ERROR DE PARAMETROS
*2 RUTA DE ENTRADA NO VALIDA
*3 RUTA DE SALIDA NO VALIDA
*4 ARCHIVO DE ENTRADA NO ENCONTRADO
*5 ARCHIVO DE SALIDA EXISTE PERO NO PUDO SER SOBRESCRITO
*6 ORIGEN Y DESTINO SON IDENTICOS

********************************************************

FUNCTION COPYFILE
PARAMETERS ARCH_ENT, ARCH_SAL, FILA, COLUMNA
IF ARCH_ENT = NIL
PARAERROR("COPYFILE()")
RETURN 1
ENDIF
IF PCOUNT() < 2 .OR. PCOUNT() >= 2 .AND. ARCH_SAL = NIL
PRIVATE ARCH_SAL := DISKNAME()+":\"+CURDIR()
        IF SUBSTR(ARCH_SAL,LEN(ARCH_SAL),LEN(ARCH_SAL)) = "\"
        PRIVATE ARCH_SAL := STUFF(ARCH_SAL,LEN(ARCH_SAL),LEN(ARCH_SAL),"")
        ENDIF
ENDIF

IF PCOUNT() < 3 .OR. PCOUNT() >= 3 .AND. FILA = NIL
PRIVATE FILA := ROW()
ENDIF

IF PCOUNT() < 4 .OR. PCOUNT() >= 4 .AND. COLUMNA = NIL
PRIVATE COLUMNA := 0
ENDIF

IF ARCH_ENT = ARCH_SAL
RETURN 6
ENDIF


PRIVATE RUTA_ENT := SOLO_RUTA(ARCH_ENT)

IF ISRUTA(ARCH_SAL)
PRIVATE RUTA_SAL := ARCH_SAL
PRIVATE CLASE := "RUTA"
        IF !ISRUTA(RUTA_SAL)
        RETURN 3
        ENDIF

ELSE
PRIVATE RUTA_SAL := SOLO_RUTA(ARCH_SAL)
        IF RUTA_SAL = ""
        PRIVATE RUTA_SAL := SOLO_RUTA(ARCH_SAL)+"\"+FILE_NAME(ARCH_SAL)
        ENDIF
PRIVATE CLASE := "ARCHIVO"
        IF !ISRUTA(SOLO_RUTA(ARCH_SAL))
        RETURN 3
        ENDIF
ENDIF

IF !ISRUTA(RUTA_ENT) 
RETURN 2
ENDIF

IF !FILE(ARCH_ENT)
RETURN 4
ENDIF

IF FILE(ARCH_SAL) .AND. !ISWRITE(ARCH_SAL)
RETURN 5
ENDIF

ADIRECTORIO := DIRECTORY(ARCH_ENT)
AEVAL( ADIRECTORIO, {|AARCHIVO| SCOPY(AARCHIVO[1],RUTA_SAL,CLASE,FILA,COLUMNA,RUTA_ENT)} )

RETURN 0

**********FUNCION EXPANDIR *****************************
*EXPANDE UNA VARIABLE SEPARANDO UNA CANTIDAD EQUITATIVA
*DE CARACTERES CON UN CARACTER DELIMITADOR.
********************************************************

FUNCTION EXPANDIR
PARAMETERS VARIABLE, INICIO, DELIM

IF VARIABLE = NIL
PARAERROR("EXPANDIR()")
ENDIF

IF INICIO != NIL
PRIVATE INICIO := INICIO
ELSE
PRIVATE INICIO := 1
ENDIF

IF DELIM != NIL .AND. INICIO != NIL
PRIVATE DELIM := DELIM
ELSE
PRIVATE DELIM := " "
ENDIF

PRIVATE CONT1 := 1
PRIVATE CONT2 := 1
PRIVATE VAR1 := ""
DO WHILE CONT1 <= LEN(VARIABLE)
        PRIVATE VAR1 := VAR1 + SBSTR(VARIABLE,CONT1,1)
        IF CONT2 >= INICIO
                PRIVATE VAR1 := VAR1 + DELIM
                PRIVATE CONT2 := 0
        ENDIF
        PRIVATE CONT1 := CONT1 + 1
        PRIVATE CONT2 := CONT2 + 1
ENDDO
RETURN VAR1

**********FUNCION CARTRIM *****************************
*OBTENER UNA CADENA CON TODOS LOS CARACTERES IGUALES AL
*CARACTER ESPECIFICADO BORRADOS.
*******************************************************

FUNCTION CARTRIM
PARAMETERS CADENA, CARACTER

IF CADENA = NIL
PARAERROR("CARTRIM()")
ENDIF

IF CARACTER = NIL
PRIVATE CARACTER := " "
ENDIF

DO WHILE AT(CARACTER,CADENA) != 0
        PRIVATE CADENA := STUFF(CADENA,AT(CARACTER,CADENA),LEN(CARACTER),"")
ENDDO
RETURN CADENA

**********FUNCION FILESPACE *****************************
*OBTENER LA LONGITUD LEIBLE DEL ARCHIVO EN BYTES.
*******************************************************

FUNCTION FILESPACE
PARAMETERS ARCHIVO
IF ARCHIVO = NIL
PARAERROR("FILESPACE()")
ENDIF

PRIVATE HANDLE := FOPEN(ARCHIVO)
PRIVATE BYTES := FSEEK(HANDLE,0,2)
FCLOSE(HANDLE)
RETURN BYTES

**********FUNCION DRIVE *****************************
*DEVUELVE LA UNIDAD DESDE UN ARCHIVO ESPECIFICADO.
*******************************************************

FUNCTION DRIVE
PARAMETERS ARCHIVO
IF ARCHIVO = NIL
PARAERROR("DRIVE()")
ENDIF

PRIVATE ARCHIVO := ALLTRIM(ARCHIVO)
IF SBSTR(ARCHIVO,2,2) = ":"
        PRIVATE UNIDAD := EXTRAE(ARCHIVO,":",1)
ELSE
        PRIVATE UNIDAD := DISKNAME()
ENDIF
RETURN UNIDAD

**********FUNCION HMATH*****************************
*DIBUJA UNA HOJA CUADRICULADA DE CUALQUIER TAMA•O.
*******************************************************

FUNCTION HMATH
PARAMETERS FSUP,COLIZQ,FINFI,COLDEREC, IFBOX
IF PCOUNT() < 4 .AND. PCOUNT() != 0
PARAERROR("PARED()")
ENDIF
PRIVATE IFBOX := TYPE_TO(IFBOX,.T.)
IF EMPTY(IFBOX)
PRIVATE IFBOX := .F.
ENDIF
SAVE SCREEN TO ANTERIOR

CLEAR
PRIVATE FI := 0
DO WHILE FI <= MAXROW()
@FI,0 SAY REPLICATE("≈ƒ",(MAXCOL()/2)+1)
@FI+1,0 SAY REPLICATE("≥ ",(MAXCOL()/2)+1)
PRIVATE FI := FI + 2
ENDDO

        IF IFBOX
        @0,0,MAXROW(),MAXCOL() BOX "⁄ƒø≥Ÿƒ¿≥"
        ENDIF

IF PCOUNT() != 0
PRIVATE M := SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
CLEAR
RESTORE SCREEN FROM ANTERIOR
RESTSCREEN(FSUP,COLIZQ,FINFI,COLDEREC,M)
        IF IFBOX
        @FSUP,COLIZQ,FINFI,COLDEREC BOX "⁄ƒø≥Ÿƒ¿≥"
        ENDIF
ENDIF
RETURN NIL

**********FUNCION PAUSA01*****************************
*EFECTUA UNA PAUSA01 ININTERRUPIDA.
*******************************************************

FUNCTION PAUSA01
PARAMETERS TIEMPO,IFKEY
PRIVATE INICIO := SEC_TIME()
PRIVATE INICIO1 := INICIO
PRIVATE NUM := TYPE_TO(TIEMPO,0)
DO WHILE .T.
PRIVATE TOPE := SEC_TIME()
PRIVATE TOPE := TOPE - INICIO
IF IFKEY != NIL .AND. IFKEY = .T.
PRIVATE TECLA_PAUS := WAITKEY()
ELSE
PRIVATE TECLA_PAUS := INKEY()
ENDIF
IF TOPE >= NUM
EXIT
ENDIF
ASETFP(INICIO1,SEC_TIME())
ENDDO
RETURN TECLA_PAUS

**********FUNCION DOSSHELL*****************************
*EFECTUA UNA IMITACION DEL SHELL A DOS.
*******************************************************

FUNCTION DOSSHELL
PARAMETERS SALIR, BAT_ARCH
IF SALIR != NIL
PRIVATE SALIR := TYPE_TO(SALIR,0)
SET FUNCTION SALIR TO "EXIT"+CHR(13)
ENDIF
IF BAT_ARCH != NIL
PRIVATE BAT_ARCH := TYPE_TO(BAT_ARCH)
RUN (BAT_ARCH)
ENDIF
COM = ""
DO WHILE .T.
SET SCOREBOARD OFF
SET EXACT ON
SET CONFIRM ON
SET FUNCTION 3 TO ALLTRIM(COM)
? ""
PRIVATE C_AT := COLOR_AT(ROW(),COL())
SETCOLOR(C_AT+","+C_AT)
R = ROW()
C = COL()
COLOR_SAY(DISKNAME()+":\"+CURDIR()+">",R,C)
PRIVATE COM := ""
PRIVATE COM := TXT(COM,R,COL())
IF COM = ""
SETPOS(R,C)
LOOP
ELSE
? ""
ENDIF
PRIVATE COM1 := ALLTRIM(UPPER(COM))
IF COM1 = "EXIT"
EXIT 
ENDIF

RUN (COM)
        IF MEMORY(0) < LEN(SPACE(MAXCOL()))
        ? ""
        COLOR_SAY("INSUFICIENTE MEMORIA ( "+ALLTRIM(STR(MEMORY(2)))+" KB )")
        EXIT
        ENDIF
ENDDO
RETURN NIL

**********FUNCION INSERT*****************************
*INSTALA UN CAMBIO DEL CURSOR PARA INDICAR LA MODALIDAD
*DE INSERCION EN UN ESTADO DE ESPERA.
*******************************************************

FUNCTION INSERT
PARAMETERS scINS, scINSn, mINS
IF EMPTY(scINS)
        PRIVATE scINS := 1
ENDIF
IF EMPTY(scINSn)
        PRIVATE scINSn := 2
ENDIF
IF EMPTY(mINS)
        PRIVATE mINS := .F.
ENDIF
IF !mINS
        READINSERT(.F.)
        SETCURSOR(scINS)
ELSE
        READINSERT(.T.)
        SETCURSOR(scINSn)
ENDIF
PRIVATE cINS := &("{|| __CURINS({"+ALLTRIM(STR(scINS))+","+ALLTRIM(STR(scINSn))+"})}")
SETKEY(22,cINS)
RETURN NIL

**********FUNCION SEC_TIME*****************************
*DEVUELVE LA HORA ESPECIFICADA CONVERTIDA EN SEGUNDOS.
*******************************************************

FUNCTION SEC_TIME
PARAMETERS HORA
IF EMPTY(HORA)
PRIVATE HORA := TIME()
ENDIF
PRIVATE HORA := ALLTRIM(TYPE_TO(HORA))
PRIVATE HH := VAL(EXTRAER(HORA,":",1))
PRIVATE MM := VAL(EXTRAER(HORA,":",2))
PRIVATE SS := VAL(EXTRAER(HORA,":",3))
PRIVATE SEC := (HH*3600)+(MM*60)+SS
RETURN SEC

**********FUNCION TIME_SEC*****************************
*DEVUELVE UNA HORA EN FORMATO HH:MM:SS A PARTIR
*DE UN NUMERO DE SEGUNDOS.
*******************************************************

FUNCTION TIME_SEC
PARAMETERS SEC
IF EMPTY(SEC)
PRIVATE SEC := 0
ENDIF
PRIVATE aSEC[8]
aSEC[1] := ALLTRIM(STR(SEC/3600))
aSEC[2] := VAL(EXTRAER(aSEC[1],".",1))
aSEC[3] := VAL("0."+EXTRAER(aSEC[1],".",2))

aSEC[4] := ALLTRIM(STR(60*aSEC[3]))
aSEC[5] := VAL(EXTRAER(aSEC[4],".",1))
aSEC[6] := VAL("0."+EXTRAER(aSEC[4],".",2))

aSEC[7] := ALLTRIM(STR(60*aSEC[6]))
aSEC[8] := VAL(EXTRAER(aSEC[7],".",1))
RETURN PADL(ALLTRIM(STR(aSEC[2])),2,"0")+":"+PADL(ALLTRIM(STR(aSEC[5])),2,"0")+":"+PADL(ALLTRIM(STR(aSEC[8])),2,"0")

**********FUNCION SALIR_TO*****************************
*CONFIGURA UNA TECLA PARA SALIR.
*******************************************************

FUNCTION SALIR_TO
PARAMETERS TECLA
IF TECLA = NIL
PRIVATE TECLA := 27
ENDIF
SET KEY TECLA TO SALIR
RETURN NIL

**********FUNCION NUM_CAR*****************************
*TRADUCE UN NUMERO A PALABRAS.
*******************************************************

FUNCTION NUM_CAR
PARAMETERS NUMERO

IF NUMERO = NIL
PARAERROR("NUM_CAR()")
ENDIF

PRIVATE NUMERO := TYPE_TO(NUMERO)
PRIVATE NUMERO := VAL(ALLTRIM(NUMERO))
PRIVATE NUMERO := ALLTRIM(STR(NUMERO))
PRIVATE NUMERO := SUBSTR(NUMERO,1,4)
PRIVATE NUMERO := PADL(NUMERO,4,"0")

PRIVATE DIG4 := SUBSTR(NUMERO,4,4)
PRIVATE DIG3 := SUBSTR(NUMERO,3,3)
PRIVATE DIG2 := SUBSTR(NUMERO,2,2)
PRIVATE DIG1 := SUBSTR(NUMERO,1,1)

PRIVATE UNIDAD := UNIDAD(DIG4)
PRIVATE DECENA := DECENA(DIG3)
PRIVATE CENTENA := CENTENA(DIG2)
PRIVATE UNI_DE_MIL := UNI_DE_MIL(DIG1)

PRIVATE STR_NUM := UNI_DE_MIL+CENTENA+DECENA+UNIDAD
        IF SUBSTR(STR_NUM,1,1) = "+" .OR. SUBSTR(STR_NUM,1,1) = "-"
        PRIVATE STR_NUM := SUBSTR(STR_NUM,2,LEN(STR_NUM))
        ENDIF
PRIVATE STR_NUM := CHR(13)+STR_NUM
PRIVATE STR_NUM := CARTRIM(STR_NUM,CHR(13)+" MAS ")
RETURN STR_NUM

**********FUNCION TYPE_TO *****************************
*CAMBIA EL TIPO DE UNA EXPRESI‡N.
*******************************************************

FUNCTION TYPE_TO
PARAMETERS VAR, TIPO
IF VAR = NIL
RETURN ""
ENDIF
IF TIPO = NIL
TIPO = ""
ENDIF

IF VALTYPE(VAR) = "U"
PRIVATE VAR := DEL_VAR(TIPO)
ENDIF

IF VALTYPE(TIPO) = "A" .OR. VALTYPE(TIPO) = "B"
RETURN VAR
ENDIF

IF VALTYPE(VAR) = "A" .OR. VALTYPE(VAR) = "B"
RETURN VAR
ENDIF

PRIVATE TYPE := VALTYPE(TIPO)
PRIVATE VAR2 := TO_STR(VAR)
DO CASE
        CASE TYPE = "C" .OR. TYPE = "M"
        PRIVATE VAR2 := VAR2
        CASE TYPE = "D"
        PRIVATE VAR2 := CTOD(VAR2)
        CASE TYPE = "L"
        PRIVATE SUB := SUBSTR(ALLTRIM(CARTRIM(VAR2,".")),1,1)
                IF SUB = "T"
                PRIVATE VAR2 := .T.
                ELSE
                PRIVATE VAR2 := .F.
                ENDIF
        CASE TYPE = "N"
        PRIVATE VAR2 := VAL(VAR2)
        CASE TYPE = "U"
        PRIVATE VAR2 := NIL
        OTHERWISE
        PRIVATE VAR2 := VAR
ENDCASE
RETURN VAR2

**********FUNCION CENTRADO *****************************
*CENTRA UNA VARIABLE.
*******************************************************

FUNCTION CENTRADO
PARAMETERS VAR
IF VAR = NIL
PRIVATE VAR := (READVAR())
ENDIF
PRIVATE VAR := TYPE_TO(VAR)
PRIVATE VAR := PADC(ALLTRIM(VAR),LEN(VAR)," ")
RETURN VAR

**********FUNCION TO_LEFT *****************************
*ALINEA UNA VARIABLE HACIA LA TO_LEFT.
*******************************************************

FUNCTION TO_LEFT
PARAMETERS VAR
IF VAR = NIL
PRIVATE VAR := (READVAR())
ENDIF
PRIVATE VAR := TYPE_TO(VAR)
PRIVATE VAR := PADR(ALLTRIM(VAR),LEN(VAR)," ")
RETURN VAR

**********FUNCION TO_RIGHT *****************************
*ALINEA UNA VARIABLE HACIA LA TO_RIGHT.
*******************************************************

FUNCTION TO_RIGHT
PARAMETERS VAR
IF VAR = NIL
PRIVATE VAR := (READVAR())
ENDIF
PRIVATE VAR := TYPE_TO(VAR)
PRIVATE VAR := PADL(ALLTRIM(VAR),LEN(VAR)," ")
RETURN VAR

**********FUNCION ISWRITE_TO *****************************
*COMPRUEBA SI EL ARCHIVO PUEDE SER COPIADO EN LA UNIDAD
*ESPECIFICADA.
*******************************************************

FUNCTION ISWRITE_TO
PARAMETERS ARCHIVO, UNIDAD
IF ARCHIVO = NIL
PARAERROR("ISWRITE_TO()")
ENDIF
IF UNIDAD = NIL
PRIVATE UNIDAD := DISKNAME()
ENDIF
PRIVATE UNIDAD := TYPE_TO(UNIDAD)
PRIVATE ARCHIVO := TYPE_TO(ARCHIVO)
PRIVATE UNIDAD := NUMBER_TO(UNIDAD) 
PRIVATE SPACE_DISK := DISKSPACE(UNIDAD)
PRIVATE SPACE_FILE := FILESPACE(ARCHIVO)
PRIVATE RESULTADO := SPACE_DISK / SPACE_FILE
IF RESULTADO > 0
PRIVATE LOGRO := .T.
ELSE
PRIVATE LOGRO := .F.
ENDIF
RETURN LOGRO

**********FUNCION NUMBER_TO ***************************
*DEVUELVE EL NUMERO CORRESPONDIENTE A LA LETRA SEGÈN EL
*ORDEN DEL ABECEDARIO.
*******************************************************

FUNCTION NUMBER_TO
PARAMETERS VAR
IF VAR = NIL
PARAERROR("NUMBER_TO()")
ENDIF
PRIVATE VAR := UPPER(VAR)
PRIVATE VAR := SUBSTR(VAR,1,1)
DO CASE
        CASE !ISALPHA(VAR)
        PRIVATE NUM := 0
        CASE VAR = "A"
        PRIVATE NUM := 1
        CASE VAR = "B"
        PRIVATE NUM := 2
        CASE VAR = "C"
        PRIVATE NUM := 3
        CASE VAR = "D"
        PRIVATE NUM := 4
        CASE VAR = "E"
        PRIVATE NUM := 5
        CASE VAR = "F"
        PRIVATE NUM := 6
        CASE VAR = "G"
        PRIVATE NUM := 7
        CASE VAR = "H"
        PRIVATE NUM := 8
        CASE VAR = "I"
        PRIVATE NUM := 9
        CASE VAR = "J"
        PRIVATE NUM := 10
        CASE VAR = "K"
        PRIVATE NUM := 11
        CASE VAR = "L"
        PRIVATE NUM := 12
        CASE VAR = "M"
        PRIVATE NUM := 13
        CASE VAR = "N"
        PRIVATE NUM := 14
        CASE VAR = "•"
        PRIVATE NUM := 15
        CASE VAR = "O"
        PRIVATE NUM := 16
        CASE VAR = "P"
        PRIVATE NUM := 17
        CASE VAR = "Q"
        PRIVATE NUM := 18
        CASE VAR = "R"
        PRIVATE NUM := 19
        CASE VAR = "S"
        PRIVATE NUM := 20
        CASE VAR = "T"
        PRIVATE NUM := 21
        CASE VAR = "U"
        PRIVATE NUM := 22
        CASE VAR = "V"
        PRIVATE NUM := 23
        CASE VAR = "W"
        PRIVATE NUM := 24
        CASE VAR = "X"
        PRIVATE NUM := 25
        CASE VAR = "Y"
        PRIVATE NUM := 26
        CASE VAR = "Z"
        PRIVATE NUM := 27
        OTHERWISE
        PRIVATE NUM := 0
ENDCASE
RETURN NUM

**********FUNCION TO_NUMBER****************************
*DEVUELVE LA LETRA CORRESPONDIENTE AL NUMERO SEGÈN EL
*ORDEN DEL ABECEDARIO.
*******************************************************

FUNCTION TO_NUMBER
PARAMETERS NUM
IF NUM = NIL
PARAERROR("TO_NUMBER()")
ENDIF
PRIVATE NUM := VAL(SUBSTR(ALLTRIM(STR(NUM)),1,2))
DO CASE
        CASE NUM = 1
        PRIVATE VAR := "A"
        CASE NUM = 2
        PRIVATE VAR := "B"
        CASE NUM = 3
        PRIVATE VAR := "C"
        CASE NUM = 4
        PRIVATE VAR := "D"
        CASE NUM = 5
        PRIVATE VAR := "E"
        CASE NUM = 6
        PRIVATE VAR := "F"
        CASE NUM = 7
        PRIVATE VAR := "G"
        CASE NUM = 8
        PRIVATE VAR := "H"
        CASE NUM = 9
        PRIVATE VAR := "I"
        CASE NUM = 10
        PRIVATE VAR := "J"
        CASE NUM = 11
        PRIVATE VAR := "K"
        CASE NUM = 12
        PRIVATE VAR := "L"
        CASE NUM = 13
        PRIVATE VAR := "M"
        CASE NUM = 14
        PRIVATE VAR := "N"
        CASE NUM = 15
        PRIVATE VAR := "•"
        CASE NUM = 16
        PRIVATE VAR := "O"
        CASE NUM = 17
        PRIVATE VAR := "P"
        CASE NUM = 18
        PRIVATE VAR := "Q"
        CASE NUM = 19
        PRIVATE VAR := "R"
        CASE NUM = 20
        PRIVATE VAR := "S"
        CASE NUM = 21
        PRIVATE VAR := "T"
        CASE NUM = 22
        PRIVATE VAR := "U"
        CASE NUM = 23
        PRIVATE VAR := "V"
        CASE NUM = 24
        PRIVATE VAR := "W"
        CASE NUM = 25
        PRIVATE VAR := "X"
        CASE NUM = 26
        PRIVATE VAR := "Y"
        CASE NUM = 27
        PRIVATE VAR := "Z"
        OTHERWISE
        PRIVATE VAR := ""
ENDCASE
RETURN VAR

**********FUNCION AGREGAR_MES *****************************
*AGREGA MESES A UNA FECHA ESPECIFICADA.
*******************************************************

FUNCTION AGREGAR_MES
PARAMETERS FECHA, N_MESES
IF FECHA = NIL
PRIVATE FECHA := DATE()
ENDIF
IF N_MESES = NIL
PRIVATE N_MESES := 1
ENDIF
PRIVATE SETDATE := SET(_SET_DATEFORMAT)
SET DATE TO AMERICAN
PRIVATE FECHA := TYPE_TO(FECHA)
PRIVATE FECHA := CTOD(FECHA)
PRIVATE N_MESES := STR(VAL(VAR2CHR(N_MESES)))
PRIVATE N_MESES := STR(VAL(N_MESES)+MONTH(FECHA))
PRIVATE N_YEAR := YEAR(FECHA)
IF VAL(N_MESES) > 12
PRIVATE N_MESES := "01"
PRIVATE N_YEAR := N_YEAR + 1
ENDIF
PRIVATE FECHA1 := N_MESES+"/"+STR(DAY(FECHA))+"/"+STR(N_YEAR)
PRIVATE FECHA1 := CTOD(FECHA1)
SET(_SET_DATEFORMAT,SETDATE)
RETURN FECHA1

**************FUNCION EXP_CONT*************************************
*EXPANDE Y CONTRAE UN TROZO DE LA PANTALLA
*******************************************************************

FUNCTION EXP_CONT
PARAMETERS F1, C1, F2, C2, FI1, CO1, FI2, CO2
PRIVATE F1 := TYPE_TO(F1,0)
PRIVATE C1 := TYPE_TO(C1,0)
PRIVATE F2 := TYPE_TO(F2,0)
PRIVATE C2 := TYPE_TO(C2,0)
PRIVATE FI1 := TYPE_TO(FI1,0)
PRIVATE CO1 := TYPE_TO(CO1,0)
PRIVATE FI2 := TYPE_TO(FI2,0)
PRIVATE CO2 := TYPE_TO(CO2,0)

IF EMPTY(F1)
PRIVATE F1 := 0
ENDIF
IF EMPTY(C1)
PRIVATE C1 := 0
ENDIF
IF EMPTY(FI1)
PRIVATE FI1 := 0
ENDIF
IF EMPTY(CO1)
PRIVATE CO1 := 0
ENDIF
IF EMPTY(FI2)
PRIVATE FI2 := MAXROW()
ENDIF
IF EMPTY(CO2)
PRIVATE CO2 := MAXCOL()
ENDIF
IF EMPTY(F2)
PRIVATE F2 := 0
ENDIF
IF EMPTY(C2)
PRIVATE C2 := 0
ENDIF

PRIVATE RC := {ROW(),COL()}, SAVESEL := SAVESCREEN(FI1,CO1,FI2,CO2), EXPSAVE := SAVESCREEN(F1,C1,F2,C2), CO3 := C2, FI3 := F2
DISPBOX(F1,C1,F2,C2,REPLICATE(CHR(32),9))
PRIVATE EXPSAVE1 := SAVESCREEN(FI1,CO1,FI2,CO2)
DO WHILE .T.
RESTSCREEN(FI1,CO1,FI2,CO2,EXPSAVE1)
RESTSCR(F1,C1,FI3,CO3,EXPSAVE)
SETPOS(F1,C1)
KEYPAUSE(0,.T.,.F.)
DO CASE
        CASE LASTKEY() = 5 .AND. FI3 > FI1
        PRIVATE FI3 := FI3 - 1

        CASE LASTKEY() = 24 .AND. F1 < FI2
        PRIVATE F1 := F1 + 1

        CASE LASTKEY() = 19 .AND. CO3 > CO1
        PRIVATE CO3 := CO3 - 1

        CASE LASTKEY() = 4 .AND. C1 < CO2
        PRIVATE C1 := C1 + 1

        CASE LASTKEY() = 20
        PRIVATE F1 := FI1, C1 := CO1, FI3 := FI2, CO3 := CO2

        CASE LASTKEY() = 18
        PRIVATE FI3 := F1

        CASE LASTKEY() = 3
        PRIVATE F1 := FI3

        CASE LASTKEY() = 1
        PRIVATE CO3 := C1

        CASE LASTKEY() = 6
        PRIVATE C1 := CO3

        CASE LASTKEY() = 27 .OR. LASTKEY() = 13
        EXIT

        CASE LASTKEY() = 397 .AND. F1 > FI1
        PRIVATE F1 := F1 - 1

        CASE LASTKEY() = 401 .AND. FI3 < FI2
        PRIVATE FI3 := FI3 + 1

        CASE LASTKEY() = 26 .AND. C1 > CO1
        PRIVATE C1 := C1 - 1

        CASE LASTKEY() = 2 .AND. CO3 < CO2
        PRIVATE CO3 := CO3 + 1

        CASE LASTKEY() = 31
        PRIVATE F1 := FI1

        CASE LASTKEY() = 30
        PRIVATE F1 := FI2

        CASE LASTKEY() = 29
        PRIVATE C1 := CO1

        CASE LASTKEY() = 23
        PRIVATE C1 := CO2

        CASE LASTKEY() = 27 .OR. LASTKEY() = 10
        EXIT

ENDCASE
ENDDO
PRIVATE COORD := {F1,C1,FI3,CO3}
        IF CO3 < C1 .OR. C1 > CO3
                PRIVATE C1 := COORD[4], CO3 := COORD[2]
        ENDIF
        IF FI3 < F1 .OR. F1 > FI3
                PRIVATE F1 := COORD[3], FI3 := COORD[1]
        ENDIF
SETPOS(RC[1],RC[2])
        IF LASTKEY() = 27
                PRIVATE DEVSEL := NIL
                RESTSCREEN(FI1,CO1,FI2,CO2,SAVESEL)
        ELSE
                PRIVATE DEVSEL := {F1,C1,FI3,CO3}
        ENDIF
RETURN DEVSEL

**********************FUNCION ISALPHAKEY**************************************
*DETERMINA SI UNA LETRA DEL ABECEDARIO HA SIDO PULSADA.
******************************************************************************

FUNCTION ISALPHAKEY
PRIVATE TECLA := CHR(LASTKEY())
IF ISALPHA(TECLA)
RETURN .T.
ELSE
RETURN .F.
ENDIF
RETURN NIL

************************FUNCION EXTRAER***************************************
*OBTIENE UNA SUBCADENA DE UNA DADA, BASANDOSE EN UN DELIMITADOR.
******************************************************************************

FUNCTION EXTRAER
PARAMETERS VAR, DELIM, OCURRENCIA
IF VAR = NIL
PARAERROR("EXTRAER()")
ENDIF
PRIVATE VAR := TYPE_TO(VAR)
IF DELIM = NIL
PRIVATE DELIM := SUBSTR(VAR,LEN(VAR),LEN(VAR))
ENDIF
IF OCURRENCIA = NIL 
PRIVATE OCURRENCIA := 1
ENDIF
PRIVATE OCURRENCIA := TYPE_TO(OCURRENCIA,0)
IF OCURRENCIA <= 0
PRIVATE OCURRENCIA := 1
ENDIF
PRIVATE DELIM := TYPE_TO(DELIM)
IF AT(DELIM,VAR) = 0
RETURN ""
ENDIF
PRIVATE RESULT := WTOARRAY(VAR+DELIM,DELIM)
RETURN RESULT[IF(IF(OCURRENCIA <= 1,1,OCURRENCIA) >= LEN(RESULT),LEN(RESULT),OCURRENCIA)]

*********************************FUNCION ISREAD*******************************
*DETERMINA SI EL ARCHIVO ESPECIFICADO PUEDE O NO SER LEIDO.
******************************************************************************

FUNCTION ISREAD
PARAMETERS ARCHIVO
IF PCOUNT() < 1
PARAERROR("ISREAD()")
ENDIF
PRIVATE ARCHIVO := ALLTRIM(ARCHIVO)
PRIVATE HANDLE := FOPEN(ARCHIVO,2)
IF HANDLE = -1
        IF FERROR() = 8 .OR. FERROR() = 29 .OR. FERROR() = 5 .OR. FERROR() = 21 .OR. FERROR() = 30 .OR. FERROR() = 6 .OR. FERROR() = 2 .OR. FERROR() = 3 .OR. FERROR() = 15
                FCLOSE(HANDLE)
                RETURN .F.
        ENDIF
ELSE
        FCLOSE(HANDLE)
        RETURN .T.
ENDIF
FCLOSE(HANDLE)
RETURN NIL

************************FUNCION WINDOW_02*************************************
*DIBUJA UNA CAJA EXPLOSIVA CON ESTILO EN LA PANTALLA
******************************************************************************

FUNCTION WINDOW_02
PARAMETERS P1,P2,P3,P4,P5,P6,VEL_W
IF P1 = NIL
PRIVATE P1 := 0
ENDIF
IF P2 = NIL
PRIVATE P2 := 0
ENDIF
IF P3 = NIL
PRIVATE P3 := 0
ENDIF
IF P4 = NIL
PRIVATE P4 := 0
ENDIF
IF P6 = NIL
PRIVATE P6 := EXTRAER(SETCOLOR(),",",1)
ENDIF
IF P5 = NIL
    PRIVATE P5 := "⁄ƒ∑∫ºÕ‘≥ "
ENDIF
IF VEL_W = NIL
PRIVATE VEL_W := 0
ENDIF
PRIVATE X
PRIVATE WIND_COL := SETCOLOR()
SETCOLOR(P6)
PRIVATE SCR_1 := SAVESCREEN(P1,P2,P3+1,P4+1)
COLOR_IN(P1+1,P2+1,P3+1,P4+1,"N+/N")
@P1,P2,P3,P4 BOX P5
PRIVATE SCR_2 := SAVESCREEN(P1,P2,P3+1,P4+1)
RESTSCREEN(P1,P2,P3+1,P4+1,SCR_1)
RSCREEN(P1,P2,P3+1,P4+1,SCR_2,VEL_W,.F.)
SETCOLOR(WIND_COL)
RETURN NIL

**********************FUNCION MOUSE*******************************************
*INICIALIZA EL MOUSE Y LO POSICIONA EN EL CENTRO DE LA PANTALLA.
******************************************************************************

FUNCTION MOUSE
PARAMETERS COLOR, CAR
IF COLOR = NIL
PRIVATE COLOR := EXTRAER(SETCOLOR(),",",2)
ENDIF
IF CAR = NIL
PRIVATE CAR := CHR(24)
ENDIF

PRIVATE COLOR := INVERTATTR(COLORTON(COLOR))
PRIVATE CAR := ASC(CAR)

MINIT()
SETMCURSOR(1)
SETMPOS(-1,-1)
SETMSOFT( 255, 0, COLOR, CAR )
PRIVATE EVAFI := MAXROW()/2
PRIVATE EVAFI := ROUND(EVAFI,0)
PRIVATE EVACOL := MAXCOL()/2
PRIVATE EVACOL := ROUND(EVACOL,0)
SETMPOS(EVAFI,EVACOL)
RETURN NIL

**********************FUNCION SUPR_SCREEN*******************************************
*BORRA LOS CARACTERES ENCONTRADOS EN EL AREA DE PANTALLA SELECCIONADA.
******************************************************************************

FUNCTION SUPR_SCREEN
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC
IF FSUP = NIL
PRIVATE FSUP := 0
ENDIF
IF COLIZQ = NIL
PRIVATE COLIZQ := 0
ENDIF
IF FINFI = NIL
PRIVATE FINFI := 0
ENDIF
IF COLDEREC = NIL
PRIVATE COLDEREC := 0
ENDIF
PRIVATE supSCR := SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
RESTSCREEN(FSUP,COLIZQ,FINFI,COLDEREC,CHARMIX(SPACE(LEN(CHARODD(supSCR))),STUFF(CHARODD(STUFF(supSCR,1,0,CHR(32))),1,1,"")))
RETURN NIL

***************************FUNCION SETS_RESET*********************************
*COLOCA TODOS LOS SETS POR OMISION.
******************************************************************************

FUNCTION SETS_RESET
SET(1,.F.)
SET(2,.F.)
SET(3,2)
SET(4,"mm/dd/yy")
SET(5,1900)
SET(6,"")
SET(7,"")
SET(8,.F.)
SET(9,.F.)
SET(10,.F.)
SET(11,.F.)
SET(12,.T.)
SET(13,.F.)
SET(14,15)
SET(15,"W/N,N/W,N/N,N/N,N/W")
SET(16,1)
SET(17,.T.)
SET(18,.F.)
SET(19,"")
SET(20,"SCREEN")
SET(21,NIL)
SET(22,"")
SET(23,.F.)
SET(24,"")
SET(25,0)
SET(26,.F.)
SET(27,.F.)
SET(28,.T.)
SET(29,.F.)
SET(30,.F.)
SET(31,.T.)
SET(32,.T.)
SET(33,.F.)
SET(34,"::")
SET(35,.F.)
SET(36,0)
SET(37,.F.)
SET(38,.T.)
RETURN NIL

*********************************FUNCION KEYS_TO******************************
*ASIGNA UNA FUNCI‡N A TODO EL TECLADO.
******************************************************************************

FUNCTION KEYS_TO
PARAMETERS VAR
IF VAR = NIL
PARAERROR("KEYS_TO")
ELSE
PRIVATE VAR := TYPE_TO(VAR)
ENDIF
PRIVATE NUM := -50
DO WHILE NUM <= 500
SET KEY (NUM) TO &VAR
PRIVATE NUM := NUM + 1
ENDDO
RETURN NIL

*********************************FUNCION KEYS_NULL****************************
*ANULA EL TECLADO.
******************************************************************************

FUNCTION KEYS_NULL
KEYS_TO("NULO__")
RETURN NIL

*********************************FUNCION BUTTON01********************************
*SIMULA UNA PULSACI‡N DE UN BOTON EN LA PANTALLA.
******************************************************************************

FUNCTION BUTTON01
PARAMETERS ROW1, COL1, ROW2, COL2
IF ROW1 = NIL
PRIVATE ROW1 := 0
ELSE
PRIVATE ROW1 := TYPE_TO(ROW1,0)
ENDIF
IF ROW2 = NIL
PRIVATE ROW2 := 0
ELSE
PRIVATE ROW2 := TYPE_TO(ROW2,0)
ENDIF
IF COL1 = NIL
PRIVATE COL1 := 0
ELSE
PRIVATE COL1 := TYPE_TO(COL1,0)
ENDIF
IF COL2 = NIL
PRIVATE COL2 := 0
ELSE
PRIVATE COL2 := TYPE_TO(COL2,0)
ENDIF

INVERTCOLOR(ROW1,COL1,ROW2,COL2)
PAUSA01(0.3,.F.)
INVERTCOLOR(ROW1,COL1,ROW2,COL2)
RETURN NIL

*****************************FUNCION SAVEKEYS*********************************
*SALVA LOS SET KEYS A UNA MATRIZ.
******************************************************************************

FUNCTION SAVEKEYS
PRIVATE NUM := -50
PRIVATE KEY := {}
DO WHILE NUM <= 500
AADD(KEY,SETKEY(NUM))
PRIVATE NUM := NUM + 1
ENDDO
RETURN KEY

*****************************FUNCION RESTKEYS*********************************
*RESTAURA LOS SET KEYS DESDE UNA MATRIZ.
******************************************************************************

FUNCTION RESTKEYS
PARAMETERS KEYMATRIZ
IF KEYMATRIZ = NIL
PARAERROR("RESTKEYS()")
ENDIF
IF ACOUNT(KEYMATRIZ) = 551
PRIVATE NUM := -50
AEVAL(KEYMATRIZ,{|KEYM| SKEY(NUM,KEYM)})
ENDIF
RETURN NIL

*****************************FUNCION ERROR************************************
*PROVOCA UN ERROR.
******************************************************************************

FUNCTION ERROR
PARAMETERS N

IF N = NIL
PRIVATE N := 1
ENDIF

SET EXACT OFF
PRIVATE ROW := ROW()
DO WHILE !EMPTY(PROCNAME(N))
        PRIVATE NOMBRE := "Called from "+PROCNAME(N)+"("+ALLTRIM(TO_STR(PROCLINE(N)))+")"
        COLOR_SAY(NOMBRE,ROW,0)
PRIVATE ROW := ROW + 1
PRIVATE N := N + 1
ENDDO
QUIT
RETURN NIL

*****************************FUNCION SAVESETS*********************************
*SALVA LOS SETS A UNA MATRIZ.
******************************************************************************

FUNCTION SAVESETS
PRIVATE SET := {}
FOR NUM := 1 TO _SET_COUNT
AADD(SET,SET(NUM))
NEXT NUM
RETURN SET

*****************************FUNCION RESTSETS*********************************
*RESTAURA LOS SETS DESDE UNA MATRIZ.
******************************************************************************

FUNCTION RESTSETS
PARAMETERS SET
IF SET = NIL
PARAERROR("RESTSETS()")
ENDIF
PRIVATE NUM := 1
AEVAL(SET, {|S| RSET(S,NUM)})
RETURN NIL

*****************************UPPER_FILE***************************************
*REESCRIBE UN ARCHIVO CON LETRA MAYÈSCULA.
******************************************************************************

FUNCTION UPPER_FILE
PARAMETERS ARCH
PRIVATE FILE := MEMOREAD(ARCH)
MEMOWRIT(ARCH,UPPER(FILE))
RETURN NIL

*****************************FUNCION T_CAR_N**********************************
*TRADUCE UNA VARIABLE CARACTER DE LETRAS AL CODIGO ASCII DE LAS MISMAS.
******************************************************************************

FUNCTION T_CAR_N
PARAMETERS VAR
IF VAR = NIL
PARAERROR("T_CAR_N()")
ENDIF
PRIVATE V := ""
NUM := 1
DO WHILE NUM <= LEN(VAR) 
PRIVATE V := V + ALLTRIM(STR(ASC(SUBSTR(VAR,NUM,NUM))))+"-"
PRIVATE NUM := NUM + 1
ENDDO
IF SUBSTR(V,LEN(V),LEN(V)) = "-"
PRIVATE V := STUFF(V,LEN(V),1,"")
ENDIF
RETURN V

*****************************FUNCION T_NUM_C**********************************
*TRADUCE UNA VARIABLE CARACTER DE CODIGO ASCII A LETRAS CORRESPONDIENTES.
******************************************************************************

FUNCTION T_NUM_C
PARAMETERS V
IF V = NIL
PARAERROR("T_NUM_C()")
ENDIF
PRIVATE NUM := 1
PRIVATE VAR := ""
DO WHILE NUM <= LEN(V)
PRIVATE VAR := VAR + CHR(VAL(EXTRAER(V,"-",NUM)))
PRIVATE NUM := NUM + 1
ENDDO
RETURN VAR

*****************************FUNCION DELSTUFF*********************************
*REEMPLAZA TODOS LOS CARACTERES IGUALES AL ESPECIFICADO PRESENTES EN UNA
*VARIABLE.
******************************************************************************

FUNCTION DELSTUFF
PARAMETERS CADENA, CARACTER, REEMPLAZO

IF CADENA = NIL
PARAERROR("DELSTUFF()")
ENDIF

IF CARACTER = NIL
PRIVATE CARACTER := " "
ENDIF

IF REEMPLAZO = NIL
PRIVATE REEMPLAZO := ","
ENDIF

IF ISCARACTER(REEMPLAZO,CARACTER) != 0
RETURN CADENA
ENDIF
DO WHILE ISCARACTER(CADENA,CARACTER) != 0
        PRIVATE CADENA := STUFF(CADENA,ISCARACTER(CADENA,CARACTER),LEN(CARACTER),RESTATTR( REEMPLAZO,ATTRVAR( SBSTR( CADENA,ISCARACTER(CADENA,CARACTER),LEN(CARACTER)))))
ENDDO
RETURN CADENA

*****************************FUNCION KEYPAUSE*********************************
*ES UNA PAUSA, PERO TOMA EN CUENTA LAS TECLAS ALT, CTRL; Y LOS BOTONES DEL 
*MOUSE.
******************************************************************************

FUNCTION KEYPAUSE
PARAMETERS TIEMPO,IFKEY,IFALT,IFCTRL
IF IFALT = NIL
PRIVATE IFALT := .T.
ENDIF
IF IFCTRL = NIL
PRIVATE IFCTRL := .F.
ENDIF
PRIVATE INICIO := SEC_TIME()
PRIVATE INICIO1 := INICIO
PRIVATE T := TIEMPO
PRIVATE NUM := TYPE_TO(TIEMPO,0)
PRIVATE TIEMPO := NUM
DO WHILE .T.
PRIVATE TOPE := SEC_TIME()
PRIVATE TOPE := TOPE - INICIO
IF IFKEY != NIL .AND. IFKEY = .T.
PRIVATE TECLA_PAUS := WAITKEY()
ELSE
PRIVATE TECLA_PAUS := INKEY()
ENDIF
IF TIEMPO = 0
PRIVATE TOPE := NUM - 1
ENDIF
IF ALT() .AND. IFALT
EXIT
ENDIF
IF CTRL() .AND. IFCTRL
EXIT
ENDIF
IF TOPE >= NUM .OR. TECLA_PAUS != 0 .OR. MPULSADO() .OR. T = NIL
EXIT
ENDIF
ASETFP(INICIO1,SEC_TIME())
MUPDATE()
ENDDO
RETURN TECLA_PAUS

*****************************FUNCION IS_ALT***********************************
*INFORMA SI LA TECLA ALT HA SIDO PULSADA. 
******************************************************************************

FUNCTION IS_ALT
PARAMETERS KEYLAST
IF KEYLAST = NIL
PRIVATE KEYLAST := LASTKEY()
ENDIF
IF ALT() .AND. KEYLAST = 0
RETURN .T.
ELSE
RETURN .F.
ENDIF
RETURN NIL

*****************************FUNCION IS_CTRL**********************************
*INFORMA SI LA TECLA ALT HA SIDO PULSADA. 
******************************************************************************

FUNCTION IS_CTRL
PARAMETERS KEYLAST
IF KEYLAST = NIL
PRIVATE KEYLAST := LASTKEY()
ENDIF
IF CTRL() .AND. KEYLAST = 0
RETURN .T.
ELSE
RETURN .F.
ENDIF
RETURN NIL

*********************************FUNCION ALPHA_TO*****************************
*ASIGNA UNA FUNCI‡N A TODO EL TECLADO ALFABETICO.
******************************************************************************

FUNCTION ALPHA_TO
PARAMETERS VAR
IF VAR = NIL
PARAERROR("ALPHA_TO")
ELSE
PRIVATE VAR := TYPE_TO(VAR)
ENDIF
PRIVATE NUM := 65
DO WHILE NUM <= 122
SET KEY (NUM) TO &VAR
PRIVATE NUM := NUM + 1
ENDDO
RETURN NIL

*********************************FUNCION NUMERIC_TO***************************
*ASIGNA UNA FUNCI‡N A TODO EL TECLADO NUMERICO.
******************************************************************************

FUNCTION NUMERIC_TO
PARAMETERS VAR
IF VAR = NIL
PARAERROR("NUMERIC_TO")
ELSE
PRIVATE VAR := TYPE_TO(VAR)
ENDIF
PRIVATE NUM := 48
DO WHILE NUM <= 57
SET KEY (NUM) TO &VAR
PRIVATE NUM := NUM + 1
ENDDO
RETURN NIL

*********************************FUNCION MELODY*******************************
*ASIGNA UNA MELODIA A TODO EL TECLADO ALFABETICO.
******************************************************************************

FUNCTION MELODY
ALPHA_TO("MELODY__")
RETURN NIL

*********************************FUNCION CHR_MEL*******************************
*TOCA UNA MELODIA SEGUN LOS CARACTERES DE LA VARIABLE.
******************************************************************************

FUNCTION CHR_MEL
PARAMETERS VAR
PRIVATE LASTK := LASTKEY()
PRIVATE CHAR := 1
DO WHILE CHAR <= LEN(VAR)
SETLASTKEY(ASC(SUBSTR(VAR,CHAR,1)))
MELODY__()
PRIVATE CHAR := CHAR + 1
ENDDO
SETLASTKEY(LASTK)
RETURN NIL

*********************************FUNCION INVERTCHAR***************************
*DEVUELVE LA VARIABLE ESPECIFICADA EN FORMA INVERTIDA.
******************************************************************************

FUNCTION INVERTCHAR
PARAMETERS CHARACTER
IF CHARACTER = NIL
PARAERROR("INVERTCHAR()")
ENDIF

PRIVATE CHARAC1 := ""
PRIVATE CHR := LEN(CHARACTER)
DO WHILE CHR >= 1
PRIVATE CHR1 := SUBSTR(CHARACTER,CHR,1)
PRIVATE CHARAC1 := CHARAC1 + CHR1
PRIVATE CHR := CHR - 1
ENDDO
RETURN CHARAC1

*********************************FUNCION SAVEMELODY***************************
*ES IGUAL QUE MELODY PERO SALVA LAS TECLAS PULSADAS A UNA VARIABLE PUBLICA
*EN FORMA DE CADENA DE CARACTERES.
******************************************************************************

FUNCTION SAVEMELODY
PRIVATE KW := ""
PRIVATE K := 0
DO WHILE ISALPHA(CHR(K)) .OR. K = 0
PRIVATE K := KEYPAUSE(0,.F.,.F.,.F.)
        IF ISALPHA(CHR(K))
        PRIVATE KW := KW+CHR(K)
        ENDIF
MELODY__()
ENDDO
RETURN KW

*********************************FUNCION FILE_PATH****************************
*BUSCA UN ARCHIVO EN EL PATH DEL DOS.
******************************************************************************

FUNCTION FILE_PATH
PARAMETERS FILE
IF FILE = NIL
PARAERROR("FILE_PATH()")
ENDIF
PRIVATE FILE := FILE_NAME(FILE)
PRIVATE PATH := GETENV("PATH")

IF SUBSTR(PATH,1,1) = ";"
PRIVATE PATH := STUFF(PATH,1,1,"")
ENDIF

IF SUBSTR(PATH,LEN(PATH),1) = ";"
PRIVATE PATH := STUFF(PATH,LEN(PATH),1,"")
ENDIF

PRIVATE IF_FILE := .F.
PRIVATE FILE1 := PATH+"\"+FILE
IF FILE(FILE1)
PRIVATE IF_FILE := .T.
RETURN IF_FILE
ENDIF

PRIVATE C := 1
DO WHILE C <= (REPITCAR(PATH,";")+1)
PRIVATE FILE1 := EXTRAER(PATH,";",C)+"\"+FILE
IF FILE(FILE1)
PRIVATE IF_FILE := .T.
EXIT
ENDIF
PRIVATE C := C + 1
ENDDO
RETURN IF_FILE

*********************************FUNCION COLOR_SAY****************************
*MUESTRA UN MENSAJE EN LOS COLORES DE LA PANTALLA.
******************************************************************************

FUNCTION COLOR_SAY
PARAMETERS VAR_SAY, FI1, C, FI, CO, IFEXIT
IF VAR_SAY = NIL
PARAERROR("COLOR_SAY")
ENDIF

IF FI1 = NIL
PRIVATE FI1 := ROW()
ENDIF

IF C = NIL
PRIVATE C := COL()
ENDIF

IF FI = NIL
PRIVATE FI := MAXROW()
ENDIF

IF CO = NIL
PRIVATE CO := MAXCOL()
ENDIF

        IF FI1 > MAXROW()
        SCROLL(0,0,MAXROW(),MAXCOL(),1)
        PRIVATE FI1 := MAXROW()
        ENDIF

IF VALTYPE(TYPE_TO(VAR_SAY,"")) != "C"
RETURN NIL
ENDIF

IF IFEXIT = NIL
PRIVATE IFEXIT := .F.
ENDIF

VAR_SAY = TYPE_TO(VAR_SAY,"")
PRIVATE F := FI1
PRIVATE C1 := C
PRIVATE N := 1
PRIVATE SCUR := SETCURSOR()
PRIVATE C_ANTER := SETCOLOR()
DO WHILE N <= LEN(VAR_SAY)
SETCURSOR(.F.)
SETCOLOR(NTOCOLOR(SCREENATTR(F,C1)))
@F,C1 SAY SUBSTR(VAR_SAY,N,1)
PRIVATE C1 := C1 + 1
PRIVATE N := N + 1
IF C1 >= CO+1
        IF F < FI
        PRIVATE F := F + 1
        ELSE
                IF IFEXIT
                EXIT
                ELSE
                PRIVATE F := FI1
                ENDIF
        ENDIF
PRIVATE C1 := C
ENDIF
ENDDO
SETCURSOR(SCUR)
SETCOLOR(C_ANTER)
RETURN NIL

*********************************FUNCION RFILE********************************
*DEVUELVE UN NOMBRE DE ARCHIVO ALEATORIO.
******************************************************************************

FUNCTION RFILE()
PRIVATE RF1 := SUBSTR(CARTRIM(INVERTCHAR(REPLICATE(STR(SEC_TIME()),15)),"."),1,6)+SUBSTR(TIME(),7,8)
PRIVATE RF := ""
PRIVATE C := 1
DO WHILE C <= LEN(RF1)
PRIVATE RF := RF+TO_NUMBER(VAL(SUBSTR(RF1,C,1)))
PRIVATE C := C + 1
ENDDO
RETURN RF

*********************************FUNCION AVM**********************************
*ALTERNA EL MODO DE VISUALIZACION DE LA PANTALLA.
******************************************************************************

FUNCTION AVM
PRIVATE SMODE := .F.
DO CASE
        CASE MAXROW() = 24
        PRIVATE SMODE := SETMODE(43,0)
        CASE MAXROW() = 42
        PRIVATE SMODE := SETMODE(50,0)
        CASE MAXROW() = 49
        PRIVATE SMODE := SETMODE(25,0)
ENDCASE
DO CASE
        CASE MAXCOL() = 39
        PRIVATE SMODE := SETMODE(0,80)
        CASE MAXCOL() = 79
        PRIVATE SMODE := SETMODE(0,40)
ENDCASE
RETURN SMODE

*********************************FUNCION WINDOW_03****************************
*DIBUJA UNA CAJA DE TRIPLE COLOR.
******************************************************************************

FUNCTION WINDOW_03
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC, CADENA, COLOR_1, COLOR_2, COLOR_3

IF FSUP = NIL
PRIVATE FSUP := 0
ENDIF

IF COLIZQ = NIL
PRIVATE COLIZQ := 0
ENDIF

IF FINFI = NIL
PRIVATE FINFI := 0
ENDIF

IF COLDEREC = NIL
PRIVATE COLDEREC := 0
ENDIF

IF CADENA = NIL
PRIVATE CADENA := ( CHR(218) + CHR(196) + CHR(191) + CHR(179) + CHR(217) + CHR(196) + CHR(192) + CHR(179) + CHR(32))

ENDIF

IF COLOR_1 = NIL
PRIVATE COLOR_1 := CARTRIM(SETCOLOR(),"/")
PRIVATE COLOR_1 := CARTRIM(COLOR_1,"+")
PRIVATE COLOR_1 := CARTRIM(COLOR_1,"*")
PRIVATE COLOR_1 := SUBSTR(COLOR_1,1,1)+"+/"+SUBSTR(COLOR_1,2,2)
ENDIF

IF COLOR_2 = NIL
PRIVATE COLOR_2 := EXTRAER(SETCOLOR(),",",1)
ENDIF

IF COLOR_3 = NIL
PRIVATE COLOR_3 := NTOCOLOR(SCREENATTR(FSUP+1,COLIZQ+1))
ENDIF

PRIVATE COLOR_ANT := SETCOLOR()
SETCOLOR(COLOR_2)
DISPBOX(FSUP,COLIZQ,FINFI,COLDEREC,CADENA)
COLOR_IN(FSUP,COLIZQ,FSUP,COLDEREC-1,COLOR_1)
COLOR_IN(FSUP,COLIZQ,FINFI,COLIZQ,COLOR_1)
COLOR_IN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1,COLOR_3)
SETCOLOR(COLOR_ANT)
RETURN {SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC),FSUP,COLIZQ,FINFI,COLDEREC,COLOR_1,COLOR_2,COLOR_3,CADENA}

*********************************FUNCION BUTTON02*****************************
*SIMULACION DE PULSACION DE UN BOTTON. ESTA FUNCION ESTA DISE•ADA UNICAMENTE
*PARA USARLA CON EJECUSIONES DE WINDOW_03().
******************************************************************************

FUNCTION BUTTON02
PARAMETERS MATRIZ, TIEMPO
IF MATRIZ = NIL
PARAERROR("BUTTON02()")
ENDIF
IF TIEMPO = NIL .OR. TIEMPO = 0
PRIVATE TIEMPO := 0.001
ENDIF
PRIVATE SCUR := SETCURSOR()
PRIVATE SCR := MATRIZ[1]
PRIVATE FSUP := MATRIZ[2]
PRIVATE COLIZQ := MATRIZ[3]
PRIVATE FINFI := MATRIZ[4]
PRIVATE COLDEREC := MATRIZ[5]
PRIVATE COLOR_1 := MATRIZ[6]
PRIVATE COLOR_2 := MATRIZ[7]
PRIVATE COLOR_3 := MATRIZ[8]
PRIVATE CADENA := MATRIZ[9]

PRIVATE SCR2 := SAVESCREEN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1)
RESTSCREEN(FSUP,COLIZQ,FINFI,COLDEREC,SCR)

IF SUBSTR(PADR(CADENA,9," "),9,1) = " "
PRIVATE SCR1 := SCR2
ELSE
PRIVATE SCR1 := SAVESCREEN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1)
ENDIF
SETCURSOR(0)
WINDOW_03(FSUP,COLIZQ,FINFI,COLDEREC,CADENA,COLOR_2,COLOR_1,COLOR_3)
RESTSCREEN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1,SCR1)
COLOR_IN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1,COLOR_3)
PAUSA01(TIEMPO)
WINDOW_03(FSUP,COLIZQ,FINFI,COLDEREC,CADENA,COLOR_1,COLOR_2,COLOR_3)
RESTSCREEN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1,SCR1)
COLOR_IN(FSUP+1,COLIZQ+1,FINFI-1,COLDEREC-1,COLOR_3)
SETCURSOR(SCUR)
RETURN NIL

*********************************FUNCION MENBUTTON****************************
*ES UN MENU CON DE OPCIONES EN FORMA DE BOTONES.
******************************************************************************

FUNCTION MENBUTTON
PARAMETERS MATRIZ, COLOR_A, COLOR_B, COLOR_C, CAD_FRONT, CAD_FONDO, POSICION, N_REPAG, B_FUNC, N_TIME, MODALEXIT
IF EMPTY(MATRIZ)
PARAERROR("MENBUTTON()")
ENDIF
IF COLOR_A = NIL
PRIVATE COLOR_A := CARTRIM(SETCOLOR(),"/")
PRIVATE COLOR_A := CARTRIM(COLOR_A,"+")
PRIVATE COLOR_A := CARTRIM(COLOR_A,"*")
PRIVATE COLOR_A := SUBSTR(COLOR_A,1,1)+"+/"+SUBSTR(COLOR_A,2,2)
ENDIF
IF COLOR_B = NIL
PRIVATE COLOR_B := EXTRAER(SETCOLOR(),",",1)
ENDIF
IF COLOR_B = NIL
PRIVATE COLOR_B := NTOCOLOR(SCREENATTR(FSUP+1,COLIZQ+1))
ENDIF
IF CAD_FRONT = NIL
PRIVATE CAD_FRONT := "⁄ƒø≥Ÿƒ¿≥"
ENDIF
IF CAD_FONDO = NIL
PRIVATE CAD_FONDO := CAD_FRONT
ENDIF
IF POSICION = 0 .OR. POSICION = NIL
PRIVATE POSICION := 1
ENDIF
IF N_REPAG = NIL
PRIVATE N_REPAG := 3
ENDIF
PRIVATE N_REPAG := TYPE_TO(N_REPAG,1)
PRIVATE SCUR := SETCURSOR()
PRIVATE C_ANTER := SETCOLOR()
PRIVATE WOPMENB := {}
AEVAL(MATRIZ,{|BLOQUE| PROMPT_TO(BLOQUE)})
PRIVATE OPMENB := POSICION
PRIVATE STATUS := 0
        DO WHILE .T.
        SETCURSOR(0)
                IF SET(_SET_WRAP)
                        DO CASE
                                CASE OPMENB < 1
                                OPMENB := LEN(MATRIZ)
                                CASE OPMENB > LEN(MATRIZ)
                                OPMENB := 1
                        ENDCASE
                ELSE
                        DO CASE
                                CASE OPMENB <= 1
                                OPMENB := 1
                                CASE OPMENB >= LEN(MATRIZ)
                                OPMENB := LEN(MATRIZ)
                        ENDCASE
                ENDIF

        PRIVATE MEN := MATRIZ[OPMENB]
        WINDOW_03(MEN[1]-1,MEN[2]-1,MEN[1]+1,MEN[2]+LEN(MEN[3]),CAD_FRONT,COLOR_A,COLOR_B,COLOR_C)
        SETCOLOR(EXTRAER(SETCOLOR(),",",2))
        @MEN[1],MEN[2] SAY MEN[3]
                IF LEN(MEN) > 3 .AND. !EMPTY(MEN[4])
                SETCOLOR(C_ANTER)
                        IF SET(_SET_MCENTER)
                        @SET(_SET_MESSAGE),((MAXCOL()+1)-LEN(TYPE_TO(MEN[4])))/2 SAY TYPE_TO(MEN[4])
                        ELSE
                        @SET(_SET_MESSAGE),0 SAY TYPE_TO(MEN[4])
                        ENDIF
                ENDIF
        SETPOS(MEN[1],MEN[2])
        SETCOLOR(C_ANTER)
        IF !EMPTY(B_FUNC) .AND. VALTYPE(B_FUNC) = "B"
        EVAL(B_FUNC,STATUS,OPMENB)
        ENDIF
                IF EMPTY(N_TIME) .OR. VALTYPE(N_TIME) != "N"
                PRIVATE N_TIME := 0
                ENDIF
        PRIVATE STATUS := 0
        PRIVATE P := PAUSA02(N_TIME,.F.)
        IF !EMPTY(B_FUNC) .AND. VALTYPE(B_FUNC) = "B"
                IF P != 0
                PRIVATE STATUS := 1
                ENDIF
        ENDIF
        SETCOLOR(COLOR_A)
        DISPBOX(MEN[1]-1,MEN[2]-1,MEN[1]+1,MEN[2]+LEN(MEN[3]),CAD_FONDO)
        SETCOLOR(COLOR_C)
        @MEN[1],MEN[2] SAY MEN[3]
        SETPOS(MEN[1],MEN[2])
                DO CASE
                        CASE P = 5 .OR. P = 19
                                DO CASE
                                        CASE MODALEXIT = 0 .AND. P = 5 .AND. READEXIT()
                                        EXIT
                                        CASE MODALEXIT = 1 .AND. P = 19 .AND. READEXIT()
                                        EXIT
                                        OTHERWISE
                                        OPMENB := OPMENB - 1
                                ENDCASE
                        CASE P = 24 .OR. P = 4
                                DO CASE
                                        CASE MODALEXIT = 0 .AND. P = 24 .AND. READEXIT()
                                        EXIT
                                        CASE MODALEXIT = 1 .AND. P = 4 .AND. READEXIT()
                                        EXIT
                                        OTHERWISE
                                        OPMENB := OPMENB + 1
                                ENDCASE
                        CASE P = 13
                        EXIT
                        CASE P = 27
                        OPMENB := 0
                        EXIT
                        CASE P = 1
                        OPMENB := 1
                        CASE P = 6
                        OPMENB := LEN(MATRIZ)
                        CASE P = 18
                        OPMENB := OPMENB - N_REPAG
                        CASE P = 3
                        OPMENB := OPMENB + N_REPAG
                ENDCASE
        ENDDO
IF OPMENB != 0
BUTTON02(WOPMENB[OPMENB],0.5)
ENDIF
SETCOLOR(C_ANTER)
SETCURSOR(SCUR)
RETURN OPMENB

*********************************FUNCION CALC*********************************
*ES UNA CALCULADORA.
******************************************************************************

FUNCTION CALC
PARAMETERS FSUP, COLIZQ, COLOR_A1, COLOR_B2, COLOR_C3, KEYMOVE, N_MEM
PRIVATE SCRCALC := SAVESCREEN(0,0,MAXROW(),MAXCOL())
PRIVATE SETC := SETCURSOR()
PRIVATE RC := ROW()
PRIVATE CC := COL()
IF KEYMOVE = NIL .OR. KEYMOVE = 0
PRIVATE KEYMOVE := 306
ENDIF
PRIVATE COL_ANT := SETCOLOR()
IF N_MEM = NIL
PRIVATE MEMORIA := "0"
ELSE
PRIVATE MEMORIA := ALLTRIM(TO_STR(CALCULO(TYPE_TO(N_MEM))))
ENDIF
SETCOLOR(COLOR_C3)
PRIVATE KEY_F1 := SETKEY(28)
PRIVATE SK := SAVEKEYS()
PRIVATE CT := ""
PRIVATE OPCALC := 1
IF EMPTY(CT)
CT := "0"
ENDIF
DO WHILE .T.
SETCURSOR(0)
KEYS_TO("CTXT__")
SETKEY(28,KEY_F1)
SETKEY(KEYMOVE,{|| MOVECALC()})
SETKEY(32,{|| KEYSTUFF(13)})
SETKEY(-33,{|| KEYFESC()})
SETKEY(9,{|| KEYSTUFF(4)})

IF FSUP = NIL
PRIVATE FSUP := 0
ENDIF
IF COLIZQ = NIL
PRIVATE COLIZQ := 0
ENDIF
IF (FSUP+16) >= MAXROW()
PRIVATE FSUP := MAXROW()-16
ENDIF
IF (COLIZQ+27) >= MAXCOL()
PRIVATE COLIZQ := MAXCOL()-27
ENDIF
RESTSCREEN(0,0,MAXROW(),MAXCOL(),SCRCALC)
WINDOW_03(FSUP,COLIZQ,FSUP+16,COLIZQ+27,,COLOR_A1,COLOR_B2,COLOR_C3)
WINDOW_03(FSUP+1,COLIZQ+1,FSUP+3,COLIZQ+26,,COLOR_B2,COLOR_A1,COLOR_C3)

PRIVATE ARRAY_M := {{FSUP+5,COLIZQ+2,"9"},{FSUP+5,COLIZQ+5,"8"},{FSUP+5,COLIZQ+8,"7"},{FSUP+8,COLIZQ+2,"6"},{FSUP+8,COLIZQ+5,"5"},{FSUP+8,COLIZQ+8,"4"},{FSUP+11,COLIZQ+2,"3"},{FSUP+11,COLIZQ+5,"2"},{FSUP+11,COLIZQ+8,"1"},{FSUP+14,COLIZQ+2,"0"},{FSUP+14,COLIZQ+5,","},{FSUP+14,COLIZQ+8,"+"},{FSUP+5,COLIZQ+11,"ˆ"},{FSUP+8,COLIZQ+11,"X"},{FSUP+11,COLIZQ+11,"ƒ"},{FSUP+14,COLIZQ+11,"Õ"},{FSUP+5,COLIZQ+14,"C"},{FSUP+8,COLIZQ+14,"\/ÓÓ"},{FSUP+11,COLIZQ+14," X % de "},{FSUP+14,COLIZQ+14,"  1/X  "},{FSUP+5,COLIZQ+17,CHR(27)+"Back"},{FSUP+8,COLIZQ+20,"MR"},{FSUP+5,COLIZQ+24,"MS"},{FSUP+8,COLIZQ+24,"MC"},{FSUP+11,COLIZQ+24,"M+"},{FSUP+14,COLIZQ+23,"OFF"}}

@FSUP+2,COLIZQ+2 SAY SUBSTR(TO_RIGHT(PADC(CT,10000," ")),LEN( TO_RIGHT( PADC(CT,10000," ")))-23,LEN(TO_RIGHT(PADC(CT,10000," "))))
CALC_1()
DO CASE
        CASE OPCALC = 11 .AND. !ISLEN(CT)
                IF !UNODEC(CT)
                CT := CT + "."        
                ENDIF
        CASE OPCALC = 12 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT))) + "+"

        CASE OPCALC = 13 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT))) + "/"        

        CASE OPCALC = 14 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT))) + "*"        

        CASE OPCALC = 15 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT))) + "-"        

        CASE OPCALC = 16 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT)))

        CASE OPCALC = 17 .OR. LASTKEY() = 27
        CT := "0"        

        CASE OPCALC = 18 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(SQRT(TYPE_TO(CALCULO(CT),1))))

        CASE OPCALC = 19 .AND. !ISLEN(CT)
        CT := ALLTRIM(TO_STR(CALCULO(CT))) + "%"        

        CASE OPCALC = 20 .AND. !ISLEN(CT)
        CT := ALLTRIM(STR(1/TYPE_TO(CALCULO(CT),1)))

        CASE OPCALC = 21 .AND. !ISLEN(CT)
        CT := STUFF(CT,LEN(CT),1,"")
        IF EMPTY(CT)
        CT := "0"
        ENDIF

        CASE OPCALC = 22 .AND. !ISLEN(CT)
        KEYBOARD MEMORIA        

        CASE OPCALC = 23 .AND. !ISLEN(CT)
        MEMORIA := ALLTRIM(TO_STR(CALCULO(CT)))

        CASE OPCALC = 24 .AND. !ISLEN(CT)
        MEMORIA := "0"       

        CASE OPCALC = 25 .AND. !ISLEN(CT)
        MEMORIA := TYPE_TO(CALCULO(CT),1)+TYPE_TO(MEMORIA,1)
        MEMORIA := ALLTRIM(STR(MEMORIA))

        CASE OPCALC = 26
        EXIT
       
        CASE !ISLEN(CT)
        CT := CT+ALLTRIM(TO_STR(10-OPCALC))

ENDCASE
IF EMPTY(CT)
CT := "0"
ENDIF
@FSUP+2,COLIZQ+2 SAY SUBSTR(TO_RIGHT(PADC(CT,10000," ")),LEN(TO_RIGHT(PADC(CT,10000," ")))-23,LEN(TO_RIGHT(PADC(CT,10000," "))))
ENDDO
CT := CALCULO(CT)
SETPOS(RC,CC)
SETCURSOR(SETC)
SETCOLOR(COL_ANT)
KEYS_TO("")
RESTKEYS(SK)
RETURN {TYPE_TO(CALCULO(CT),1),TYPE_TO(CALCULO(MEMORIA),1)}

*********************************FUNCION WORDS********************************
*DEVUELVE UN ARRAY CON LAS PALABRAS DE UNA EXPRESION CARACTER.
******************************************************************************

FUNCTION WORDS
PARAMETERS WORDS
IF WORDS = NIL
PARAERROR("WORDS()")
ENDIF
PRIVATE WORDS := ALLTRIM(WORDS)
PRIVATE C := 1
PRIVATE W1 := {}
DO WHILE C <= LEN(WORDS) .AND. LEN(W1) < 4096
PRIVATE W := ""
        DO WHILE ISALPHA(SUBSTR(WORDS,C,1)) .OR. ISDIGIT(SUBSTR(WORDS,C,1))
        PRIVATE W := W+SUBSTR(WORDS,C,1)
        PRIVATE C := C + 1
        ENDDO
AADD(W1,W)
PRIVATE C := C + 1
ENDDO
IF ACOUNT(W1) = 0
W1 := {""}
ENDIF
RETURN W1

*********************************FUNCION GETLONG******************************
*ES UN GET CON UNA LONGITUD VISIBLE DETERMINADA Y UNA LONGITUD
*REAL INDEFINIDA.
******************************************************************************

FUNCTION GETLONG
PARAMETERS RW, CL, VAR, nDESP, PIC, VALD, WHN
SETPOS(RW,CL)
PRIVATE vS := &(VAR)
READMODAL({_GET_(vS,(VAR),("@S"+ALLTRIM(STR(nDESP))+CHR(32)+TYPE_TO(PIC)),VALD,WHN)})
RETURN NIL

*********************************FUNCION LINES********************************
*DEVUELVE UN ARRAY CON TODAS LAS LINEAS DE UNA VARIABLE.
******************************************************************************

FUNCTION LINES
PARAMETERS VAR, NLINE
IF VAR = NIL
PARAERROR("LINES()")
ENDIF
IF EMPTY(NLINE)
PRIVATE NLINE := 1
ENDIF

        IF LEN(VAR) <= NLINE
        RETURN {VAR}
        ENDIF

PRIVATE VAR1 := {}
PRIVATE CHRN := ATNOT(VAR)
PRIVATE VAR := EXPANDIR(VAR,NLINE,CHRN)
FOR N := 1 TO REPITCAR(VAR,CHRN)+1
AADD(VAR1,EXTRAER(VAR,CHRN,N))
NEXT
RETURN VAR1

*********************************FUNCION RSCREEN******************************
*RESTAURA UNA PANTALLA CON EFECTO EXPLOTAR.
******************************************************************************

FUNCTION RSCREEN
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC, SCREEN, TIME, IFCLEAR
PRIVATE SCUR := {ROW(),COL()}
IF FSUP = NIL
PRIVATE FSUP := 0
ENDIF
IF COLIZQ = NIL
PRIVATE COLIZQ := 0
ENDIF
IF FINFI = NIL
PRIVATE FINFI := 0
ENDIF
IF COLDEREC = NIL
PRIVATE COLDEREC := 0
ENDIF
IF SCREEN = NIL
PRIVATE SCREEN := SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC)
ENDIF
IF TIME = NIL
PRIVATE TIME := 0.05
ENDIF
IF IFCLEAR = NIL
PRIVATE IFCLEAR := .F.
ENDIF

IF IFCLEAR
@FSUP,COLIZQ CLEAR TO FINFI,COLDEREC
ENDIF

PRIVATE FSUP := TYPE_TO(FSUP,1)
PRIVATE COLIZQ := TYPE_TO(COLIZQ,1)
PRIVATE FINFI := TYPE_TO(FINFI,1)
PRIVATE COLDEREC := TYPE_TO(COLDEREC,1)

PRIVATE EVAFI := ROUND((FINFI - FSUP)/2,0)
PRIVATE EVACOL := ROUND((COLDEREC - COLIZQ)/2,0)
PRIVATE F1 := FSUP+EVAFI
PRIVATE C1 := COLIZQ+EVACOL
PRIVATE F2 := FINFI-EVAFI
PRIVATE C2 := COLDEREC-EVACOL
PRIVATE EVAFI1 := ROUND((F2 - F1)/2,0)
PRIVATE EVACOL1 := ROUND((C2 - C1)/2,0)

DO WHILE EVAFI1 <= EVAFI .OR. EVACOL1 <= EVACOL
RESTSCREEN(F1,C1,F2,C2,SCREEN)
        DO CASE
                CASE EVAFI1 < EVAFI
                F1 := F1 - 1
                F2 := F2 + 1
                CASE EVACOL1 < EVACOL                
                C1 := C1 - 1
                C2 := C2 + 1
                OTHERWISE
                EXIT
        ENDCASE
EVAFI1 := ROUND((F2 - F1)/2,0)
EVACOL1 := ROUND((C2 - C1)/2,0)
PAUSA01(TIME)
ENDDO
SETPOS(SCUR[1],SCUR[2])
RETURN NIL

*********************************FUNCION TRADUCTOR****************************
*TRADUCE EXPRESIONES CARACTERES HASTA EN CINCO IDIOMAS.
******************************************************************************

FUNCTION TRADUCTOR
PARAMETERS CHARACTER, IDIOMAS, N_ID1, N_ID2
IF CHARACTER = NIL .OR. IDIOMAS = NIL
PARAERROR("TRADUCTOR()")
ENDIF
IF N_ID1 = NIL
PRIVATE N_ID1 := 1
ENDIF
IF N_ID2 = NIL
PRIVATE N_ID2 := 2
ENDIF

IF N_ID1 <= 0
N_ID1 := 1
ENDIF
IF N_ID2 <= 0
N_ID2 := 1
ENDIF
IF N_ID1 > LEN(IDIOMAS)
N_ID1 := LEN(IDIOMAS)
ENDIF
IF N_ID2 > LEN(IDIOMAS)
N_ID2 := LEN(IDIOMAS)
ENDIF
IF LEN(IDIOMAS[N_ID1]) < 1 .OR. LEN(IDIOMAS[N_ID2]) < 1
RETURN CHARACTER
ENDIF
IF LEN(IDIOMAS[N_ID1]) != LEN(IDIOMAS[N_ID2])
RETURN CHARACTER
ENDIF

PRIVATE N := 1
AEVAL(IDIOMAS[N_ID1],{|ID| TRADUC(ID,IDIOMAS[N_ID2])})
RETURN CHARACTER

*********************************FUNCION ARRAY_DEP****************************
*DEPURA UN ARRAY.
******************************************************************************

FUNCTION ARRAY_DEP
PARAMETERS ARRAY
IF ARRAY = NIL
PARAERROR("ARRAY_DEP()")
ENDIF
PRIVATE ARRAY2 := {}
PRIVATE N := 1
AEVAL(ARRAY,{|A| ADEP(A)})
RETURN ARRAY2

*********************************FUNCION MOVE_TO******************************
*MUEVE LA PANTALLA SELECCIONADA HACIA DONDE UNO QUIERE
*SEGUN LA ORDEN ESPECIFICADA.
******************************************************************************

FUNCTION MOVE_TO
PARAMETERS FI1,CO1,FI2,CO2,TO
IF FI1 = NIL .OR. CO1 = NIL .OR. FI2 = NIL .OR. CO2 = NIL .OR. TO = NIL
PARAERROR("MOVE_TO()")
ENDIF
PRIVATE TO1 := ALLTRIM(STR(ABS(VAL(EXTRAER(TO,",",1)))))
PRIVATE TO2 := UPPER(ALLTRIM(EXTRAER(TO,",",2)))
DO CASE
        CASE TO2 = "UP"
        SCROLL(FI1,CO1,FI2,CO2,VAL("+"+TO1))

        CASE TO2 = "DOWN"
        SCROLL(FI1,CO1,FI2,CO2,VAL("-"+TO1))

        CASE TO2 = "LEFT"
        SCR := SAVESCREEN(FI1,CO1+VAL(TO1),FI2,CO2)
        @FI1,CO1 CLEAR TO FI2,CO2
        RESTSCREEN(FI1,CO1,FI2,CO2-VAL(TO1),SCR)

        CASE TO2 = "RIGHT"
        SCR := SAVESCREEN(FI1,CO1,FI2,CO2-VAL(TO1))
        @FI1,CO1 CLEAR TO FI2,CO2
        RESTSCREEN(FI1,CO1+VAL(TO1),FI2,CO2,SCR)

ENDCASE
RETURN NIL

*********************************FUNCION ATOWORD******************************
*CONVIERTE UN ARRAY EN CADENA DE CARACTERES.
******************************************************************************

FUNCTION ATOWORD
PARAMETERS ARRAY, DELIM
PRIVATE VAR := ""
ATREE(ARRAY,{|v| (VAR += IF(VALTYPE(TYPE_TO(v)) == "C",TYPE_TO(v),".!nontype≠.") + IF(VALTYPE(TYPE_TO(DELIM)) == "C",TYPE_TO(DELIM),".!nontype≠."))})
RETURN VAR

*********************************FUNCION PAUSA02******************************
*ES UNA PAUSA QUE TOMA EN CUENTA LOS SET KEY, PERO QUE NO IGNORA LA PULSACION
*DE LAS TECLAS DE ESTOS.
******************************************************************************

FUNCTION PAUSA02
PARAMETERS TIEMPO,IFALT,IFCTRL
IF IFALT = NIL
PRIVATE IFALT := .T.
ENDIF
IF IFCTRL = NIL
PRIVATE IFCTRL := .F.
ENDIF
PRIVATE INICIO := SEC_TIME()
PRIVATE INICIO1 := INICIO
PRIVATE T := TIEMPO
PRIVATE NUM := TYPE_TO(TIEMPO,0)
PRIVATE TIEMPO := NUM
DO WHILE .T.
PRIVATE TOPE := SEC_TIME()
PRIVATE TOPE := TOPE - INICIO
PRIVATE TECLA_PAUS := INKEY()
DOSETKEY(TECLA_PAUS)
IF TIEMPO = 0
PRIVATE TOPE := NUM - 1
ENDIF
IF ALT() .AND. IFALT
EXIT
ENDIF
IF CTRL() .AND. IFCTRL
EXIT
ENDIF
IF TOPE >= NUM .OR. TECLA_PAUS != 0 .OR. T = NIL
EXIT
ENDIF
ASETFP(INICIO1,SEC_TIME())
ENDDO
RETURN TECLA_PAUS

*********************************FUNCION KEYWORD()****************************
*ES IGUAL QUE EL COMANDO KEYBOARD, PERO CON MAYOR ALCANCE.
******************************************************************************

FUNCTION KEYWORD
PARAMETERS KEYWORD
IF KEYWORD = NIL .OR. VALTYPE(TYPE_TO(KEYWORD)) != "C"
RETURN KEYBUFFER()
ENDIF
PRIVATE KEYWORD := TYPE_TO(KEYWORD)
PRIVATE KBUFF := KEYBUFFER()
PRIVATE NUM := 1
DO WHILE NUM <= LEN(KEYWORD)
KEYSTUFF(ASC(SUBSTR(KEYWORD,NUM,1)))
NUM := NUM + 1
ENDDO
RETURN KBUFF

***************************FUNCION ARRAY_NUM**********************************
*CALCULA EL NUMERO DE DIMENSIONES O ELEMENTOS DE UNA MATRIZ.
******************************************************************************

FUNCTION ARRAY_NUM
PARAMETERS ARRAY
PRIVATE NUM := 0
AEVAL(ARRAY,{|| COUNT()})
RETURN NUM

***************************FUNCION WTOARRAY***********************************
*CONVIERTE UNA CADENA EN ARRAY A PARTIR DE UN DELIMITADOR.
******************************************************************************

FUNCTION WTOARRAY
PARAMETERS WTOA, DEL
IF WTOA = NIL
PARAERROR("WTOARRAY()")
ENDIF
IF DEL = NIL
PRIVATE DEL := " "
ENDIF
PRIVATE WTOA1 := {}
PRIVATE DEL := SBSTR(DEL,1,LEN(WTOA))
PRIVATE atWTOA := AT(DEL,WTOA)
DO WHILE atWTOA != 0 .AND. LEN(WTOA1) < 4096
        PRIVATE atWTOA := AT(DEL,WTOA)
        PRIVATE lfWTOA := LEFT(WTOA,atWTOA-1)
        IF !EMPTY(LEN(lfWTOA))
                AADD(WTOA1,lfWTOA)
        ENDIF
        PRIVATE WTOA := STUFF(WTOA,1,(atWTOA-1)+LEN(DEL),"")
ENDDO
RETURN WTOA1

***************************FUNCION MENUFILE***********************************
*MENU DE ARCHIVOS.
******************************************************************************

FUNCTION MENUFILE
PARAMETERS FROW, FCOL, FPATH, aFNAME, FTYPES, FTITLE, FCOLOR1, FCOLOR2, FCOLOR3, FMKMOVE

PRIVATE FROW := TYPE_TO(FROW,0)
PRIVATE FCOL := TYPE_TO(FCOL,0)
PRIVATE FPATH := TYPE_TO(FPATH)
PRIVATE FTITLE := TYPE_TO(FTITLE)
PRIVATE FCOLOR1 := TYPE_TO(FCOLOR1)
PRIVATE FCOLOR2 := TYPE_TO(FCOLOR2)
PRIVATE FCOLOR3 := TYPE_TO(FCOLOR3)
PRIVATE FMKMOVE := TYPE_TO(FMKMOVE,0)

IF EMPTY(FROW)
        PRIVATE FROW := 0
ENDIF
IF EMPTY(FCOL)
        PRIVATE FCOL := 0
ENDIF
IF EMPTY(FPATH)
        PRIVATE FPATH := DISKNAME() + ":\" + CURDIR()
ENDIF

IF ISRUTA(FPATH)
        PRIVATE mfDC := {DISKNAME(),"\" + CURDIR()}
        RUN (DRIVE(FPATH) + ":")
        RUN ("CD " + FPATH)
        PRIVATE FPATH := DISKNAME() + ":\" + CURDIR()
        RUN (mfDC[1] + ":")
        RUN ("CD " + mfDC[2])
ELSE
        PRIVATE FPATH := DISKNAME() + ":\" + CURDIR()
ENDIF
PRIVATE FPATH := RIGHTDEL(FPATH,"\") + "\"

IF EMPTY(FCOLOR1)
        PRIVATE FCOLOR1 := CARTRIM(SETCOLOR(),"/")
        PRIVATE FCOLOR1 := CARTRIM(FCOLOR1,"+")
        PRIVATE FCOLOR1 := CARTRIM(FCOLOR1,"*")
        PRIVATE FCOLOR1 := SUBSTR(FCOLOR1,1,1)+"+/"+SUBSTR(FCOLOR1,2,2)
ENDIF
IF EMPTY(FCOLOR2)
        PRIVATE FCOLOR2 := EXTRAER(SETCOLOR(),",",1)
ENDIF
IF EMPTY(FCOLOR3)
        PRIVATE FCOLOR3 := NTOCOLOR(SCREENATTR(FROW,FCOL))
ENDIF

PRIVATE FCOLOR4 := ""
EVAL({|x| NULL(SETCOLOR(FCOLOR3),(FCOLOR4 := EXTRAER(SETCOLOR(),",",4)),SETCOLOR(x))},SETCOLOR())

IF EMPTY(FMKMOVE)
        PRIVATE FMKMOVE := 306
ENDIF
IF EMPTY(aFNAME)
        PRIVATE aFNAME := {""}
ENDIF
IF EMPTY(FTYPES)
        PRIVATE FTYPES := {{"*.*","Todos los archivos"}}
ENDIF

SAVE SCREEN TO mfSCR

@FROW,FCOL SAY PADR(FTITLE,52," ")
SETCOLOR(FCOLOR3)
WINDOW_03(FROW+1,FCOL,FROW+22,FCOL+51,,FCOLOR1,FCOLOR2,FCOLOR3)
WINDOW_03(FROW+2,FCOL+11,FROW+4,FCOL+35,,FCOLOR2,FCOLOR1,FCOLOR4)
@FROW+3,FCOL+1 SAY "Buscar en:"
WINDOW_03(FROW+8,FCOL+1,FROW+15,FCOL+40,,FCOLOR2,FCOLOR1,FCOLOR4)
WINDOW_03(FROW+5,FCOL+1,FROW+7,FCOL+14,,FCOLOR1,FCOLOR1,FCOLOR3)
@FROW+6,FCOL+2 SAY "Nombre"
WINDOW_03(FROW+5,FCOL+15,FROW+7,FCOL+28,,FCOLOR1,FCOLOR1,FCOLOR3)
@FROW+6,FCOL+16 SAY "Tipo"
WINDOW_03(FROW+5,FCOL+29,FROW+7,FCOL+40,,FCOLOR1,FCOLOR1,FCOLOR3)
@FROW+6,FCOL+30 SAY "Modificado"
SETCOLOR(FCOLOR3)
WINDOW_03(FROW+16,FCOL+19,FROW+18,FCOL+45,,FCOLOR2,FCOLOR1,FCOLOR4)
@FROW+17,FCOL+1 SAY "Nombre de Archivo:"
WINDOW_03(FROW+19,FCOL+19,FROW+21,FCOL+45,,FCOLOR2,FCOLOR1,FCOLOR4)
@FROW+20,FCOL+1 SAY "Tipo de Archivo:"
WINDOW_03(FROW+2,FCOL+41,FROW+4,FCOL+50,,FCOLOR1,FCOLOR1,FCOLOR3)
WINDOW_03(FROW+5,FCOL+41,FROW+7,FCOL+50,,FCOLOR1,FCOLOR1,FCOLOR3)
@FROW+3,FCOL+42 SAY "Aceptar"
@FROW+6,FCOL+42 SAY "Cancelar"
PRIVATE FSCREEN := SAVESCREEN(FROW,FCOL,FROW+22,FCOL+51)

PRIVATE CHFUNC := 1
PRIVATE bORGANI := {{|X,Y| X[1] < Y[1]},{|X,Y| X[1] < Y[1]},1}
PRIVATE nFTYPES := 1
PRIVATE FNAME := aFNAME[1]

PRIVATE fTYPES1 := {{},{}}
AEVAL(FTYPES,{|ft| NULL(AADD(fTYPES1[1],ft[1]),AADD(fTYPES1[2],ft[2]))})
PRIVATE FTYPES := ACLONE(fTYPES1)

PRIVATE mfEXIT := .F.
PRIVATE mfACEPT := NIL
PRIVATE mfNAMEold := RIGHTDEL(FPATH,"\") + "\" + RIGHTDEL(SBSTR(ALLTRIM(UPPER(EXTRAER(FNAME,".",1))),1,8)+"."+SBSTR(ALLTRIM(UPPER(EXTRAER(FNAME,".",2))),1,3),".")


DO WHILE .T.
        PRIVATE FNAME := EXOMI(FILE_NAME(FNAME),__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FILE_NAME(FNAME),".",2)))

        // Variables de MENFUNC5()
        PRIVATE dfMENUmf51 := {}
        AEVAL(DIRECTORY(RIGHTDEL(FPATH,"\")+"\*.*","D"),{|dfm1| IF(dfm1[5] == "D" .AND. dfm1[1] != "." .AND. dfm1[1] != "..",AADD(dfMENUmf51,dfm1),.F.)})

        PRIVATE dfMENUmf52 := DIRECTORY(RIGHTDEL(FPATH,"\")+"\"+FTYPES[1][nFTYPES],"HS")

        PRIVATE ndfMENUmf51 := 1
        AEVAL(dfMENUmf51,{|df| AADD(dfMENUmf51[ndfMENUmf51++],mf5TYPE(df[1],df[5]))})
        PRIVATE ndfMENUmf52 := 1
        AEVAL(dfMENUmf52,{|df| AADD(dfMENUmf52[ndfMENUmf52++],mf5TYPE(df[1],df[5]))})

        ASORT(dfMENUmf51,,,bORGANI[1])
        ASORT(dfMENUmf52,,,bORGANI[2])
        
        PRIVATE dfMENUmf5[LEN(dfMENUmf51)+LEN(dfMENUmf52)]
        ACOPY(dfMENUmf51,dfMENUmf5)
        ACOPY(dfMENUmf52,dfMENUmf5,,,LEN(dfMENUmf51)+1)
        
        PRIVATE dMENUmf5 := {}
        AEVAL(dfMENUmf5,{|df| AADD(dMENUmf5,PADR(df[1],12," ")+SPACE(2)+mf5TYPE(df[1],df[5])+SPACE(2)+PADR(DTOC(df[3]),10," "))})

        // Variables de MENFUNC4()
        PRIVATE dMENUmf4 := WTOARRAY(FPATH,"\")
        dMENUmf4[1] := dMENUmf4[1]+"\"
        PRIVATE ISdUNI := .F.
        IF LEN(dMENUmf4) <= 1
        PRIVATE dMENUmf4 := ARRAYDRIVE()
        PRIVATE ISdUNI := .T.
        ENDIF

SETCOLOR(FCOLOR4)
RESTSCREEN(FROW,FCOL,FROW+22,FCOL+51,FSCREEN)
        IF REPITCAR(RIGHTDEL(FPATH,"\"),"\") > 0
                @FROW+3,FCOL+12 SAY dMENUmf4[LEN(dMENUmf4)]
        ELSE
                @FROW+3,FCOL+12 SAY RIGHTDEL(FPATH,"\") + "\"
        ENDIF
        IF CHFUNC != 5
                PRIVATE Ftv := FROW+9
                AEVAL(dMENUmf5,{|df| NULL(DEVPOS(Ftv++,FCOL+2),DEVOUT(df))},1,6)
        ENDIF

        @FROW+17,FCOL+20 SAY FNAME
        @FROW+20,FCOL+20 SAY PADR(FTYPES[2][nFTYPES],25,CHR(32))

        DO CASE
                CASE CHFUNC = 1
                MENFUNC1()
                CASE CHFUNC = 2
                MENFUNC2()
                CASE CHFUNC = 3
                MENFUNC3()
                CASE CHFUNC = 4
                MENFUNC4()
                CASE CHFUNC = 5
                MENFUNC5()
        ENDCASE
        DO CASE
                CASE LASTKEY() = 27
                PRIVATE mfACEPT := .F.
                EXIT
                CASE LASTKEY() = 13 .AND. mfEXIT
                        IF CHFUNC != 3
                        PRIVATE mfACEPT := .T.
                        ENDIF
                EXIT
                CASE LASTKEY() = 19
                IF CHFUNC > 1
                        PRIVATE CHFUNC := CHFUNC - 1
                ELSE
                        PRIVATE CHFUNC := 5
                ENDIF
                CASE LASTKEY() = 4 .OR. LASTKEY() = 9
                IF CHFUNC < 5
                        PRIVATE CHFUNC := CHFUNC + 1
                ELSE
                        PRIVATE CHFUNC := 1
                ENDIF
        ENDCASE
ENDDO
PRIVATE mfNAME := NIL
DO CASE
        CASE !mfACEPT
        PRIVATE mfNAME := mfNAMEold
        CASE mfACEPT
        PRIVATE FNAME_E1 := SBSTR(ALLTRIM(UPPER(EXTRAER(FNAME,".",1))),1,8)
        PRIVATE FNAME_E2 := SBSTR(ALLTRIM(UPPER(EXTRAER(FNAME,".",2))),1,3)
        PRIVATE mfNAME := RIGHTDEL(FPATH,"\") + "\" + RIGHTDEL(IF(!EMPTY(FNAME_E1),FNAME_E1,FNAME)+"."+FNAME_E2,".")
ENDCASE
RESTORE SCREEN FROM mfSCR
RETURN mfNAME

***************************FUNCION SUBPATH************************************
*DEVUELVE UN ARRAY CON LOS SUBDIRECTORIOS DE LA RUTA ESPECIFICADA.
******************************************************************************

FUNCTION SUBPATH
PARAMETERS RUTA
IF RUTA = NIL
PRIVATE RUTA := DISKNAME()+":\"+CURDIR()
ENDIF
PRIVATE RUTA := RIGHTDEL(ALLTRIM(RUTA),"\")
IF !ISRUTA(RUTA)
RETURN {}
ENDIF
PRIVATE RUTA1 := {}
AEVAL(DIRECTORY(RUTA+"\*.*","D"),{|DR| DIRADD(DR)})
RETURN RUTA1

***************************FUNCION RIGHTDEL***********************************
*BORRA UN CARACTER DEL LADO DERECHO DE LA VARIABLE.
******************************************************************************

FUNCTION RIGHTDEL
PARAMETERS CAR, DEL
IF CAR = NIL
PARAERROR("RIGHTDEL()")
ENDIF
IF DEL = NIL
PRIVATE DEL := " "
ENDIF
DO WHILE SBSTR(CAR,LEN(CAR),1) = DEL
PRIVATE CAR := SBSTR(CAR,1,LEN(CAR)-1)
ENDDO
RETURN CAR

***************************FUNCION LEFTDEL************************************
*BORRA UN CARACTER DEL LADO IZQUIERDO DE LA VARIABLE.
******************************************************************************

FUNCTION LEFTDEL
PARAMETERS CAR, DEL
IF CAR = NIL
PARAERROR("LEFTDEL()")
ENDIF
IF DEL = NIL
PRIVATE DEL := " "
ENDIF
DO WHILE SBSTR(CAR,1,1) = DEL
PRIVATE CAR := SBSTR(CAR,2,LEN(CAR))
ENDDO
RETURN CAR

*********************************FUNCION BOXMENU******************************
*ES UN MENU QUE SOPORTA MAS DE UNA LINEA EN OPCIONES.
******************************************************************************

FUNCTION BOXMENU
PARAMETERS MAT, COLOR_A, COLOR_B, COLOR_C, CAD_FRONT, CAD_FONDO, POSICION, N_REPAG, B_FUNC, N_TIME
IF EMPTY(MAT)
PARAERROR("BOXMENU()")
ENDIF
IF COLOR_A = NIL
PRIVATE COLOR_A := CARTRIM(SETCOLOR(),"/")
PRIVATE COLOR_A := CARTRIM(COLOR_A,"+")
PRIVATE COLOR_A := CARTRIM(COLOR_A,"*")
PRIVATE COLOR_A := SUBSTR(COLOR_A,1,1)+"+/"+SUBSTR(COLOR_A,2,2)
ENDIF
IF COLOR_B = NIL
PRIVATE COLOR_B := EXTRAER(SETCOLOR(),",",1)
ENDIF
IF COLOR_B = NIL
PRIVATE COLOR_B := NTOCOLOR(SCREENATTR(FSUP+1,COLIZQ+1))
ENDIF
IF CAD_FRONT = NIL
PRIVATE CAD_FRONT := "⁄ƒø≥Ÿƒ¿≥"
ENDIF
IF CAD_FONDO = NIL
PRIVATE CAD_FONDO := CAD_FRONT
ENDIF
IF POSICION = 0 .OR. POSICION = NIL
PRIVATE POSICION := 1
ENDIF
IF N_REPAG = NIL
PRIVATE N_REPAG := 3
ENDIF
PRIVATE CAD_FONDO := SBSTR(CAD_FONDO,1,8)
PRIVATE CAD_FRONT := SBSTR(CAD_FRONT,1,8)
PRIVATE SCUR := SETCURSOR()
PRIVATE C_ANTER := SETCOLOR()
PRIVATE N_REPAG := TYPE_TO(N_REPAG,1)
PRIVATE SCRVARS := {}
AEVAL(MAT,{|BLOQUE| PRMPT_TO(BLOQUE)})
PRIVATE OPBOXM := POSICION
PRIVATE STATUS := 0
        DO WHILE .T.
        SETCURSOR(0)
                IF SET(_SET_WRAP)
                        DO CASE
                                CASE OPBOXM < 1
                                OPBOXM := LEN(MAT)
                                CASE OPBOXM > LEN(MAT)
                                OPBOXM := 1
                        ENDCASE
                ELSE
                        DO CASE
                                CASE OPBOXM <= 1
                                OPBOXM := 1
                                CASE OPBOXM >= LEN(MAT)
                                OPBOXM := LEN(MAT)
                        ENDCASE
                ENDIF

        PRIVATE MEN := MAT[OPBOXM]
        WINDOW_03(MEN[1]-1,MEN[2]-1,MEN[3]+1,MEN[4]+1,CAD_FRONT,COLOR_A,COLOR_B,COLOR_C)
        SETCOLOR(EXTRAER(SETCOLOR(),",",2))
        PRIVATE SCRMEN := SCRVARS[OPBOXM]
        RESTSCREEN(SCRMEN[1],SCRMEN[2],SCRMEN[3],SCRMEN[4],SCRMEN[5])
        COLOR_IN(SCRMEN[1],SCRMEN[2],SCRMEN[3],SCRMEN[4])
                IF LEN(MEN) > 4 .AND. !EMPTY(MEN[5])
                SETCOLOR(C_ANTER)
                        IF SET(_SET_MCENTER)
                        @SET(_SET_MESSAGE),0 SAY CENTRADO(PADL(TYPE_TO(MEN[5]),MAXCOL()+1," "))
                        ELSE
                        @SET(_SET_MESSAGE),0 SAY PADR(TYPE_TO(MEN[5]),MAXCOL()+1," ")
                        ENDIF
                ENDIF
        SETPOS(MEN[1],MEN[2])
        SETCOLOR(C_ANTER)
        IF !EMPTY(B_FUNC) .AND. VALTYPE(B_FUNC) = "B"
        EVAL(B_FUNC,STATUS,OPBOXM)
        ENDIF
                IF EMPTY(N_TIME) .OR. VALTYPE(N_TIME) != "N"
                PRIVATE N_TIME := 0
                ENDIF
        PRIVATE STATUS := 0
        PRIVATE P := PAUSA02(N_TIME,.F.)
        IF !EMPTY(B_FUNC) .AND. VALTYPE(B_FUNC) = "B"
                IF P != 0
                PRIVATE STATUS := 1
                ENDIF
        ENDIF
        SETCOLOR(COLOR_A)
        DISPBOX(MEN[1]-1,MEN[2]-1,MEN[3]+1,MEN[4]+1,CAD_FONDO)
        SETCOLOR(COLOR_C)
        RESTSCREEN(SCRMEN[1],SCRMEN[2],SCRMEN[3],SCRMEN[4],SCRMEN[5])
        COLOR_IN(SCRMEN[1],SCRMEN[2],SCRMEN[3],SCRMEN[4],COLOR_C)
        SETPOS(MEN[1],MEN[2])
                DO CASE
                        CASE P = 5 .OR. P = 19
                        OPBOXM := OPBOXM - 1
                        CASE P = 24 .OR. P = 4
                        OPBOXM := OPBOXM + 1
                        CASE P = 13
                        EXIT
                        CASE P = 27
                        OPBOXM := 0
                        EXIT
                        CASE P = 1
                        OPBOXM := 1
                        CASE P = 6
                        OPBOXM := LEN(MAT)
                        CASE P = 18
                        OPBOXM := OPBOXM - N_REPAG
                        CASE P = 3
                        OPBOXM := OPBOXM + N_REPAG
                ENDCASE
        ENDDO
SETCOLOR(C_ANTER)
SETCURSOR(SCUR)
RETURN OPBOXM

*********************************FUNCION ATTRVAR******************************
*GUARDA LOS ATRIBUTOS DE UNA VARIABLE CARACTER.
******************************************************************************

FUNCTION ATTRVAR
PARAMETERS ATTRVAR
PRIVATE NUMV := 1
PRIVATE ATTRVAR1 := ""
DO WHILE NUMV <= LEN(ATTRVAR)
DO CASE
        CASE ISUPPER(SBSTR(ATTRVAR,NUMV,1))
        PRIVATE ATTRVAR1 := ATTRVAR1+"^"
        CASE ISLOWER(SBSTR(ATTRVAR,NUMV,1))
        PRIVATE ATTRVAR1 := ATTRVAR1+"_"
        OTHERWISE
        PRIVATE ATTRVAR1 := ATTRVAR1+"-"
ENDCASE
PRIVATE NUMV := NUMV + 1
ENDDO
RETURN ATTRVAR1

*********************************FUNCION RESTATTR*****************************
*RESTAURA LOS ATRIBUTOS DE UNA VARIABLE CARACTER.
******************************************************************************

FUNCTION RESTATTR
PARAMETERS ATTRVAR, ATTRVAR2
PRIVATE ATTRVAR2 := PADR(ATTRVAR2,LEN(ATTRVAR),SBSTR(ATTRVAR2,LEN(ATTRVAR2),LEN(ATTRVAR2)))
PRIVATE NUMV := 1
PRIVATE ATTRVAR1 := ""
DO WHILE NUMV <= LEN(ATTRVAR)
DO CASE
        CASE SBSTR(ATTRVAR2,NUMV,1) = "^"
        PRIVATE ATTRVAR1 := ATTRVAR1+UPPER(SBSTR(ATTRVAR,NUMV,1))
        CASE SBSTR(ATTRVAR2,NUMV,1) = "_"
        PRIVATE ATTRVAR1 := ATTRVAR1+LOWER(SBSTR(ATTRVAR,NUMV,1))
        CASE SBSTR(ATTRVAR2,NUMV,1) = "-"
        PRIVATE ATTRVAR1 := ATTRVAR1+SBSTR(ATTRVAR,NUMV,1)
        CASE SBSTR(ATTRVAR2,NUMV,1) != "-" .OR. SBSTR(ATTRVAR2,NUMV,1) != "^" .OR. SBSTR(ATTRVAR2,NUMV,1) != "_"
        ? CHR(7)
        ALERT("Incorrect character: "+UPPER(ATTRVAR2),{"QUIT"})
        ERROR(2)
ENDCASE
PRIVATE NUMV := NUMV + 1
ENDDO
RETURN ATTRVAR1

*********************************FUNCION MAXVAL*******************************
*CALCULA EL MAXIMO VALOR DE UN ARRAY.
******************************************************************************

FUNCTION MAXVAL
PARAMETERS MAXVAL
IF MAXVAL = NIL
PARAERROR("MAXVAL()")
ENDIF
IF LEN(MAXVAL) < 1
RETURN 0
ENDIF
PRIVATE MVAL := DEL_VAR(MAXVAL[1])
IF VALTYPE(MVAL) != "N" .AND. VALTYPE(MVAL) != "D"
RETURN 0
ENDIF
AEVAL(MAXVAL,{|V| MVAL(V)})
RETURN MVAL

*********************************FUNCION MINVAL*******************************
*CALCULA EL MINIMO VALOR DE UN ARRAY.
******************************************************************************

FUNCTION MINVAL
PARAMETERS MINVAL
IF MINVAL = NIL
PARAERROR("MINVAL()")
ENDIF
IF LEN(MINVAL) < 1
RETURN 0
ENDIF
PRIVATE MVAL1 := MINVAL[1]
IF VALTYPE(MVAL1) != "N" .AND. VALTYPE(MVAL1) != "D"
RETURN 0
ENDIF
AEVAL(MINVAL,{|V| MVAL1(V)})
RETURN MVAL1

*********************************FUNCION SORTDBF******************************
*ORDENA UN ARCHIVO DE BASE DE DATOS.
******************************************************************************

FUNCTION SORTDBF
PARAMETERS DBF, IDCAMPO, COND, WHL, FR
IF DBF = NIL .OR. IDCAMPO = NIL
PARAERROR("SORTDBF()")
ENDIF
PRIVATE WHL1 := "WHILE "
PRIVATE FR1 := "FOR "
IF COND = NIL
PRIVATE COND := ""
ENDIF
IF WHL = NIL
PRIVATE WHL1 := ""
PRIVATE WHL := ""
ENDIF
IF FR = NIL
PRIVATE FR1 := ""
PRIVATE FR := ""
ENDIF
PRIVATE RF := RFILE()+".RES"
PRIVATE WHL := WHL1+WHL
PRIVATE FR := FR1+FR
PRIVATE COMAND := IDCAMPO+" "+COND+" "+WHL+" "+FR
USE (DBF)
SORT TO &RF. ON &COMAND.
CLOSE DATABASE
COPY FILE (RF) TO (DBF)
ERASE (RF)
RETURN NIL

*********************************FUNCION ISRUTVAL*****************************
*VERIFICA SI EL RUT ESPECIFICADO ES VALIDO.
******************************************************************************

FUNCTION ISRUTVAL
PARAMETERS RUTVAL
       LOCAL L,DVN,I,K,J
       L=LEN(RUTVAL)
       DVN=SUBSTR(RUTVAL,l,1)
       I=L-2
       K=L-2
       J=2
       SM=0
       DO WHILE I > 0
          IF SUBSTR(RUTVAL,I,1)>="0" .AND. SUBSTR(RUTVAL,I,1)<="9"
             SM=SM+VAL(SUBSTR(RUTVAL,I,1))*J
             J=J+1
             IF J=8
                J=2
             ENDIF (J=8)

          ENDIF (SUBSTR(RUTVAL,I,1)>="0" .AND. SUBSTR(RUTVAL,I,1)<="9")
          I=I-1
       ENDDO (I>0)

       REST1 = SM - INT(SM/11)*11
       IF REST1=0
          DV="0"
        ELSE
        IF REST1=1
                DV="K"
        ELSE
           DV=STR(11-REST1,1)
        ENDIF (REST1=1)
       ENDIF (REST1=0)
       IF DV=DVN
          RETURN(.T.)
       ELSE
          RETURN(.F.)
       ENDIF
RETURN NIL

*********************************FUNCION SETFUNCP*****************************
*ASIGNA UNA FUNCION PARA QUE SE EJECUTE DURANTE UNA PAUSA DESPUES DE UN TIEMPO
*DETERMINADO.
******************************************************************************

FUNCTION SETFUNCP
PARAMETERS SFUNC, STIMER
IF EMPTY(SFUNC)
PARAERROR("SETFUNCP()")
ENDIF
IF EMPTY(STIMER)
PRIVATE STIMER := 2
ENDIF
PRIVATE SFUNC := {UPPER(ALLTRIM(TYPE_TO(SFUNC))),FMASTER()}
PRIVATE STIMER := ALLTRIM(TYPE_TO(STIMER))
MEMOWRIT(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3),SFUNC[1]+","+STIMER+","+SFUNC[2])
SETFATTR(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3),1)
RETURN NIL

*********************************FUNCION SFPCLOSE*****************************
*CIERRA EL ARCHIVO DEJADO POR SETFUNCP().
******************************************************************************

FUNCTION SFPCLOSE
SETFATTR(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3),0)
FERASE(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3))
RETURN NIL

*********************************FUNCION CIELO********************************
*DIBUJA UN CIELO EN LA PANTALLA.
******************************************************************************

FUNCTION CIELO
PARAMETERS X1,Y1,X2,Y2,ESP1,AOB,COLOR
IF EMPTY(X1)
PRIVATE X1 := 0
ENDIF
IF EMPTY(X2)
PRIVATE X2 := 0
ENDIF
IF EMPTY(Y1)
PRIVATE Y1 := 0
ENDIF
IF EMPTY(Y2)
PRIVATE Y2 := 0
ENDIF
IF EMPTY(ESP1)
PRIVATE ESP1 := 3
ENDIF
IF EMPTY(COLOR)
PRIVATE COLOR := SETCOLOR()
ENDIF
PRIVATE ESP2 := ESP1/3
SAVE SCREEN TO SCRCIELO
PRIVATE CVIEJO := SETCOLOR()
setcolor(COLOR)
@X1,Y1 CLEAR TO X2,Y2
PRIVATE CADENA := ""
X=1
DO WHILE ((X2-X1)+1)*((Y2-Y1)+1)>=LEN(CADENA)
IF EMPTY(AOB)
        PRIVATE CADENA := CADENA+REPLICATE(" ",((X**ESP1)/X))+""+REPLICATE(" ",(ESP2*X)/(X/3))+"˙"
ELSE
        PRIVATE CADENA := CADENA+REPLICATE(" ",((X**ESP1)/X))+"˙"+REPLICATE(" ",(ESP2*X)/(X/3))+""
ENDIF
X++
ENDDO
Y=0
FOR X=X1 TO X2 STEP 1
@X,Y1 SAY SUBSTR(CADENA,(1+(Y*((Y2-Y1)+1))),((Y+1)*((Y2-Y1)+1)))
Y++
NEXT
PRIVATE SCRCIELO1 := SAVESCREEN(X1,Y1,X2,Y2)
RESTORE SCREEN FROM SCRCIELO
RESTSCREEN(X1,Y1,X2,Y2,SCRCIELO1)
SETCOLOR(CVIEJO)
RETURN NIL

*********************************FUNCION FRANJA*******************************
*DIBUJA UNA FRANJA EN LA PANTALLA.
******************************************************************************

FUNCTION FRANJA
PARAMETERS FIFRA, COFRA, NCOFRA, ACTUAL, NTOTAL, CHARFRA, COLORFRA, PAINTFRA, ISVERT
PRIVATE FIFRA := TYPE_TO(FIFRA,0)
PRIVATE COFRA := TYPE_TO(COFRA,0)
PRIVATE NCOFRA := TYPE_TO(NCOFRA,0)
PRIVATE ACTUAL := TYPE_TO(ACTUAL,0)
PRIVATE NTOTAL := TYPE_TO(NTOTAL,0)
PRIVATE CHARFRA := SBSTR(TYPE_TO(CHARFRA),1,1)
PRIVATE COLORFRA := TYPE_TO(COLORFRA)
PRIVATE PAINTFRA := TYPE_TO(PAINTFRA,.T.)
PRIVATE ISVERT := TYPE_TO(ISVERT,.T.)
IF FIFRA = NIL
PRIVATE FIFRA := ROW()
ENDIF
IF COFRA = NIL
PRIVATE COFRA := COL()
ENDIF
IF NCOFRA = NIL
PRIVATE NCOFRA := MAXROW()-COFRA
ENDIF
IF NTOTAL = NIL
PRIVATE NTOTAL := NCOFRA
ENDIF
IF ACTUAL = NIL
PRIVATE ACTUAL := NTOTAL
ENDIF
IF CHARFRA = NIL
PRIVATE CHARFRA := CHR(219)
ENDIF
IF COLORFRA = NIL
PRIVATE COLORFRA := SETCOLOR()
ENDIF
IF ACTUAL >= NTOTAL
PRIVATE ACTUAL := NTOTAL
ENDIF
IF EMPTY(PAINTFRA)
PRIVATE PAINTFRA := .F.
ENDIF
IF EMPTY(ISVERT)
PRIVATE ISVERT := .F.
ENDIF
PRIVATE SCOLFRA := SETCOLOR()
PRIVATE CIENTO1 := (100*ACTUAL)/NTOTAL
PRIVATE CIENTO2 := (NCOFRA*CIENTO1)/100
IF !PAINTFRA
        SETCOLOR(COLORFRA)
        IF !ISVERT
                @FIFRA,COFRA SAY REPLICATE(CHARFRA,CIENTO2)
        ELSE
                DISPBOX(FIFRA-CIENTO2+1,COFRA,FIFRA,COFRA,REPLICATE(CHARFRA,9))
        ENDIF
ELSE
        IF !ISVERT
                COLOR_IN(FIFRA,COFRA,FIFRA,COFRA+CIENTO2-1,COLORFRA)
        ELSE
                COLOR_IN(FIFRA-CIENTO2+1,COFRA,FIFRA,COFRA,COLORFRA)
        ENDIF
ENDIF
SETCOLOR(SCOLFRA)
RETURN CIENTO1

*********************************FUNCION RESTSCR*******************************
*ES IGUAL A RESTSCREEN(), CON LA DIFERENCIA QUE NO VISUALIZA CARACTERES EXTRA•OS.
*CUANDO LAS COORDENDAS NO CORRESPONDEN.
*******************************************************************************

FUNCTION RESTSCR
PARAMETERS F1, C1, F2, C2, V
PRIVATE C := 1

FOR FI := F1 TO F2
        FOR CO := C1 TO C2
        STRSCREEN(SUBSTR(V,C,2),FI,CO)
        PRIVATE C := C + 2
        NEXT
NEXT
RETURN NIL

*********************************FUNCION ATNOT********************************
*BUSCA UN CARACTER QUE NO APAREZCA EN LA VARIABLE.
******************************************************************************

FUNCTION ATNOT
PARAMETERS V
PRIVATE V := TYPE_TO(V)
IF EMPTY(V)
PRIVATE V := ""
ENDIF
PRIVATE ATNOT := ""
PRIVATE C := 1
DO WHILE C <= 255
IF AT(CHR(C),V) = 0
PRIVATE ATNOT := CHR(C)
EXIT
ENDIF
PRIVATE C := C + 1
ENDDO
RETURN ATNOT

*********************************FUNCION CENTER*******************************
*VISUALIZA UNA VENTANA DE DIALOGO AL ESTILO WINDOW_03().
******************************************************************************

FUNCTION CENTER
PARAMETERS MENSAJE, MENOPC, TITULO, C_L_R, ISBOX, CADCENT, C_COL1, C_COL2, C_COL3

PRIVATE MENSAJE := TYPE_TO(MENSAJE)
PRIVATE TITULO := TYPE_TO(TITULO)
PRIVATE ISBOX := TYPE_TO(ISBOX,.T.)
PRIVATE C_COL1 := TYPE_TO(C_COL1)
PRIVATE C_COL2 := TYPE_TO(C_COL2)
PRIVATE C_COL3 := TYPE_TO(C_COL3)
PRIVATE C_L_R := TYPE_TO(C_L_R)
PRIVATE CADCENT := TYPE_TO(CADCENT)

IF EMPTY(MENSAJE)
PRIVATE MENSAJE := ""
ENDIF
IF EMPTY(ISBOX)
PRIVATE ISBOX := .F.
ENDIF
IF EMPTY(CADCENT)
PRIVATE CADCENT := "⁄ƒø≥Ÿƒ¿≥ "
ENDIF
IF EMPTY(C_COL1)
PRIVATE C_COL1 := CARTRIM(SETCOLOR(),"/")
PRIVATE C_COL1 := CARTRIM(C_COL1,"+")
PRIVATE C_COL1 := CARTRIM(C_COL1,"*")
PRIVATE C_COL1 := SUBSTR(C_COL1,1,1)+"+/"+SUBSTR(C_COL1,2,2)
ENDIF
IF EMPTY(C_COL2)
PRIVATE C_COL2 := EXTRAER(SETCOLOR(),",",1)
ENDIF
IF EMPTY(C_COL3)
PRIVATE C_COL3 := NTOCOLOR(SCREENATTR(ROW(),COL()))
ENDIF
IF EMPTY(C_L_R)
PRIVATE C_L_R := "C"
ENDIF

PRIVATE C_L_R := SBSTR(C_L_R,1,1)
PRIVATE ARRAYMEN := {MENSAJE}
PRIVATE LIMITC := ((7.59*MAXCOL())/100)*2
PRIVATE LIMITR := ((18*MAXROW())/100)*2
IF LEN(MENSAJE) > (MAXCOL()-LIMITC)
        PRIVATE ARRAYMEN := {}
        PRIVATE LENARRAY := MLCOUNT(MENSAJE,MAXCOL()-LIMITC,4,.T.)
                FOR z := 1 TO LENARRAY
                        IF z <= 4096
                                AADD(ARRAYMEN,ALLTRIM(MEMOLINE(MENSAJE,MAXCOL()-LIMITC,z,4,.T.)))
                        ELSE
                                EXIT
                        ENDIF
                NEXT
ENDIF
IF LEN(ARRAYMEN) > (MAXROW()-LIMITR)
        RETURN NIL
ENDIF
   MENROW := INT( ( MAXROW() - LEN(ARRAYMEN) ) / 2 ) + 1
   MENCOL := INT( ( MAXCOL() - AWIDE(ARRAYMEN) ) / 2 ) + 1
PRIVATE F1 := MENROW-1
PRIVATE C1 := MENCOL-1
PRIVATE F2 := MENROW+LEN(ARRAYMEN)
PRIVATE C2 := MENCOL+AWIDE(ARRAYMEN)
PRIVATE COVAL := (C2-C1)-1

IF EMPTY(TITULO)
PRIVATE TITULO := ALLTRIM(PADR(MENSAJE,COVAL," "))
ENDIF

PRIVATE SPOS := {ROW(),COL()}
PRIVATE SCOLOR := SETCOLOR()
PRIVATE SCRCENTER := SAVESCREEN(0,0,MAXROW(),MAXCOL())
DO CASE
        CASE C_L_R = "C"
        @F1-2,C1-1 SAY PADC(TITULO,(C2-C1)+3," ")
        CASE C_L_R = "L"
        @F1-2,C1-1 SAY PADR(TITULO,(C2-C1)+3," ")
        CASE C_L_R = "R"
        @F1-2,C1-1 SAY PADL(TITULO,(C2-C1)+3," ")
ENDCASE
WINDOW_03(F1-1,C1-1,F2+4,C2+1,CADCENT,C_COL1,C_COL2,C_COL3)
IF ISBOX
        WINDOW_03(F1,C1,F2,C2,CADCENT,C_COL2,C_COL1,C_COL3)
ENDIF
SETCOLOR(C_COL3)
        FOR i := 1 TO LEN( ARRAYMEN )
        DO CASE
                CASE C_L_R = "C"
                @MENROW++, INT((MAXCOL()-LEN(ARRAYMEN[i]))/2)+1 SAY ARRAYMEN[i]
                CASE C_L_R = "L"
                @MENROW++, MENCOL SAY ARRAYMEN[i]
                CASE C_L_R = "R"
                @MENROW++, (C2-LEN(ARRAYMEN[i])) SAY ARRAYMEN[i]
        ENDCASE
        NEXT
PRIVATE MENCENT := MENUCENTER(MENOPC)
IF !EMPTY(MENCENT)
        PRIVATE MENCENT1 := MENBUTTON(MENCENT,C_COL1,C_COL2,C_COL3,CADCENT)
ELSE
        PRIVATE MENCENT1 := 0
        PAUSA02(0,.F.,.F.)
ENDIF
RESTSCREEN(0,0,MAXROW(),MAXCOL(),SCRCENTER)
SETCOLOR(SCOLOR)
SETPOS(SPOS[1],SPOS[2])
RETURN MENCENT1

*********************************FUNCION SAYREP*******************************
*LLENA UN AREA DE LA PANTALLA CON LA VARIABLE ESPECIFICADA.
******************************************************************************

FUNCTION SAYREP
PARAMETERS LETER, F1, C1, F2, C2
PRIVATE LETER := TYPE_TO(LETER)
PRIVATE F1 := TYPE_TO(F1,0)
PRIVATE C1 := TYPE_TO(C1,0)
PRIVATE F2 := TYPE_TO(F2,0)
PRIVATE C2 := TYPE_TO(C2,0)

IF EMPTY(LETER)
PRIVATE LETER := CHR(32)
ENDIF
IF EMPTY(F1)
PRIVATE F1 := 0
ENDIF
IF EMPTY(C1)
PRIVATE C1 := 0
ENDIF
IF EMPTY(F2)
PRIVATE F2 := 0
ENDIF
IF EMPTY(C2)
PRIVATE C2 := 0
ENDIF
SAVE SCREEN TO SAVECLS1
CLS(COLORTON(SETCOLOR()),LETER)
PRIVATE SAVECLS := SAVESCREEN(F1,C1,F2,C2)
RESTORE SCREEN FROM SAVECLS1
RESTSCREEN(F1,C1,F2,C2,SAVECLS)
RETURN NIL

*********************************FUNCION BOXSAY*******************************
*MUESTRA UN MENSAJE EN EL AREA ESPECIFICADA.
******************************************************************************

FUNCTION BOXSAY
PARAMETERS F1, C1, F2, C2, LETERS, ALINEA, ISBOX, cF_cSCR
IF EMPTY(F1)
PRIVATE F1 := 0
ENDIF
IF EMPTY(C1)
PRIVATE C1 := 0
ENDIF
IF EMPTY(F2)
PRIVATE F2 := 0
ENDIF
IF EMPTY(C2)
PRIVATE C2 := 0
ENDIF
IF EMPTY(ISBOX)
PRIVATE ISBOX := .F.
ENDIF
IF ISBOX
PRIVATE F1 := F1 + 1, C1 := C1 + 1, F2 := F2 - 1, C2 := C2 - 1
ENDIF
PRIVATE scBOXs := SETCURSOR()
SETCURSOR(0)
IF EMPTY(LETERS)
        PRIVATE aLETERS := LINES(RTRIM(CHARODD(SAVESCREEN(F1,C1,F2,C2))),(C2-C1)+1)
        PRIVATE LETERS := ""
                FOR SN1 := 1 TO LEN(aLETERS)
                        PRIVATE LETERS := LETERS + RTRIM(aLETERS[SN1])
                        IF SN1 < LEN(aLETERS)
                                PRIVATE LETERS := LETERS + CHR(13)+CHR(10)
                        ENDIF
                NEXT
ENDIF
IF EMPTY(ALINEA)
PRIVATE ALINEA := "X"
ENDIF
PRIVATE ALINEA := ALLTRIM(UPPER(ALINEA))
IF ALINEA != "X" .AND. ALINEA != "R" .AND. ALINEA != "L" .AND. ALINEA != "C"
PRIVATE ALINEA := "X"
ENDIF
IF (cF_cSCR != 0 .AND. cF_cSCR != 1 .AND. cF_cSCR != 2)
PRIVATE cF_cSCR := 1
ENDIF
IF ISBOX
        DISPBOX(F1-1,C1-1,F2+1,C2+1)
ENDIF
DO CASE
        CASE cF_cSCR = 1
        DISPBOX(F1,C1,F2,C2,REPLICATE(CHR(32),9))
        CASE cF_cSCR = 2
        SUPR_SCREEN(F1,C1,F2,C2)
ENDCASE
PRIVATE LETERSscr := ""
PRIVATE PNTSN3 := F1

FOR PNTSN2 := 1 TO MLCOUNT(LETERS,(C2-C1)+1,4,.T.)
        IF PNTSN3 <= (F2)
                        PRIVATE bs := ALLTRIM(MEMOLINE(LETERS,(C2-C1)+1,PNTSN2,4,.T.))
                DO CASE
                        CASE ALINEA = "C"
                                DO CASE
                                        CASE cF_cSCR = 2
                                        COLOR_SAY(bs,PNTSN3,(C1+((C2-C1)/2)-(LEN(bs)/2)+1))
                                        OTHERWISE
                                        @PNTSN3,C1+((C2-C1)/2)-(LEN(bs)/2)+1 SAY bs
                                ENDCASE
                        CASE ALINEA = "L"
                                DO CASE
                                        CASE cF_cSCR = 2
                                        COLOR_SAY(bs,PNTSN3,C1)
                                        OTHERWISE
                                        @PNTSN3,C1 SAY bs
                                ENDCASE
                        CASE ALINEA = "R"
                                DO CASE
                                        CASE cF_cSCR = 2
                                        COLOR_SAY(bs,PNTSN3,(C2-LEN(bs))+1)
                                        OTHERWISE
                                        @PNTSN3,(C2-LEN(bs))+1 SAY bs
                                ENDCASE
                        CASE ALINEA = "X"
                                DO CASE
                                        CASE cF_cSCR = 2
                                        COLOR_SAY(MEMOLINE(LETERS,((C2-C1)+1),PNTSN2,4,.T.),PNTSN3,C1)
                                        OTHERWISE
                                        @PNTSN3,C1 SAY MEMOLINE(LETERS,(C2-C1)+1,PNTSN2,4,.T.)
                                ENDCASE
                ENDCASE
        ELSE
                EXIT
        ENDIF
        PNTSN3 := PNTSN3 + 1
NEXT
SETCURSOR(scBOXs)
RETURN NIL

*********************************FUNCION COLORPOS*****************************
*DEVUELVE EL COLOR DE LA FILA Y COLUMNA ESPECIFICADA.
******************************************************************************

FUNCTION COLORPOS
PARAMETERS FI, CO
RETURN CARTRIM(NTOCOLOR(SCREENATTR(FI,CO),.T.),CHR(32))

*********************************FUNCION CHRPOS*******************************
*DEVUELVE EL CARACTER DE LA FILA Y COLUMNA ESPECIFICADA.
******************************************************************************

FUNCTION CHRPOS
PARAMETERS FI, CO
RETURN SBSTR(SCREENSTR(FI,CO,1),1,1)

*********************************FUNCION COLORTOW*****************************
*DEVUELVE EL NOMBRE DEL COLOR CORRESPONDIENTE AL NUMERO DEL FORMATO "NN/NN"
*ESPECIFICADO, EJEMPLO: COLORTOW(7) // RESULTADO: "BLANCO".
******************************************************************************

FUNCTION COLORTOW
PARAMETERS CTOW, ISLETER
IF CTOW = NIL
PARAERROR("COLORTOW()")
ENDIF
PRIVATE CTOW := TYPE_TO(CTOW,0)
PRIVATE ISLETER := TYPE_TO(ISLETER,.T.)
IF EMPTY(ISLETER)
PRIVATE ISLETER := .F.
ENDIF
PRIVATE CTOW1 := NIL
DO CASE
        CASE CTOW = 0
                IF !ISLETER
                        PRIVATE CTOW1 := "Negro"
                ELSE
                        PRIVATE CTOW1 := "N"
                ENDIF
**
        CASE CTOW = 1 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Azul"
                ELSE
                        PRIVATE CTOW1 := "B"
                ENDIF

        CASE CTOW = 1 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Subrayado"
                ELSE
                        PRIVATE CTOW1 := "B"
                ENDIF
**
        CASE CTOW = 2 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Verde"
                ELSE
                        PRIVATE CTOW1 := "G"
                ENDIF

        CASE CTOW = 2 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "G"
                ENDIF
**
        CASE CTOW = 3 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Ciano"
                ELSE
                        PRIVATE CTOW1 := "BG"
                ENDIF

        CASE CTOW = 3 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "BG"
                ENDIF
**
        CASE CTOW = 4 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Rojo"
                ELSE
                        PRIVATE CTOW1 := "R"
                ENDIF

        CASE CTOW = 4 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "R"
                ENDIF
**
        CASE CTOW = 5 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Magenta"
                ELSE
                        PRIVATE CTOW1 := "RB"
                ENDIF

        CASE CTOW = 5 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "RB"
                ENDIF
**
        CASE CTOW = 6 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Casta§o"
                ELSE
                        PRIVATE CTOW1 := "GR"
                ENDIF

        CASE CTOW = 6 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "GR"
                ENDIF
**
        CASE CTOW = 7 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "W"
                ENDIF

        CASE CTOW = 7 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco"
                ELSE
                        PRIVATE CTOW1 := "W"
                ENDIF
**
        CASE CTOW = 8 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Gris"
                ELSE
                        PRIVATE CTOW1 := "N+"
                ENDIF

        CASE CTOW = 8 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Negro"
                ELSE
                        PRIVATE CTOW1 := "N+"
                ENDIF

**
        CASE CTOW = 9 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Azul Brillante"
                ELSE
                        PRIVATE CTOW1 := "B+"
                ENDIF

        CASE CTOW = 9 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Subrayado Brillante"
                ELSE
                        PRIVATE CTOW1 := "B+"
                ENDIF

**
        CASE CTOW = 10 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Verde Brillante"
                ELSE
                        PRIVATE CTOW1 := "G+"
                ENDIF

        CASE CTOW = 10 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "G+"
                ENDIF

**
        CASE CTOW = 11 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Ciano Brillante"
                ELSE
                        PRIVATE CTOW1 := "BG+"
                ENDIF

        CASE CTOW = 11 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "BG+"
                ENDIF

**
        CASE CTOW = 12 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Rojo Brillante"
                ELSE
                        PRIVATE CTOW1 := "R+"
                ENDIF

        CASE CTOW = 12 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "R+"
                ENDIF

**
        CASE CTOW = 13 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Magenta Brillante"
                ELSE
                        PRIVATE CTOW1 := "RB+"
                ENDIF

        CASE CTOW = 13 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "RB+"
                ENDIF

**
        CASE CTOW = 14 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Amarillo"
                ELSE
                        PRIVATE CTOW1 := "GR+"
                ENDIF

        CASE CTOW = 14 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "GR+"
                ENDIF

**
        CASE CTOW = 15 .AND. ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "W+"
                ENDIF

        CASE CTOW = 15 .AND. !ISCOLOR()
                IF !ISLETER
                        PRIVATE CTOW1 := "Blanco Brillante"
                ELSE
                        PRIVATE CTOW1 := "W+"
                ENDIF

ENDCASE
RETURN CTOW1

*********************************FUNCION PNTFORM******************************
*VERIFICA SI EL ARCHIVO POSEE FORMATO .PNT
******************************************************************************

FUNCTION PNTFORM
PARAMETERS FILEPNT
/*
PRIVATE FILEPNT := TYPE_TO(FILEPNT)
IF EMPTY(FILEPNT)
PARAERROR("PNTFORM()")
ENDIF

IF ALLTRIM(UPPER(ALIAS())) == ALLTRIM(UPPER(FILEPNT))
        ? CHR(7)
        ALERT("Error in the net: the file is in use.",{"QUIT"})
        ERROR(2)
ENDIF

PRIVATE SEXACT := SET(_SET_EXACT)
SET EXACT ON
IF SBSTR(MEMOREAD(FILEPNT),1,2) != (CHR(3)+CHR(99))
RETURN .F.
ENDIF
SET(_SET_EXACT,SEXACT)

PRIVATE NAMEDBF := {ALIAS(),RECNO()}
CLOSE DATABASE
USE (FILEPNT)
PRIVATE RFILE := RFILE()
DBCREATE(RFILE+".1",DBSTRUCT())
DBCREATE(RFILE+".2",{{"APNT1","N",10,0},{"BPNT1","N",10,0},{"CPNT1","N",10,0},{"DPNT1","N",10,0},{"EPNT1","C",860,0},{"EPNT2","C",860,0},{"EPNT3","C",860,0},{"EPNT4","C",860,0},{"EPNT5","C",860,0},{"EPNT6","C",860,0},{"EPNT7","C",860,0},{"EPNT8","C",860,0},{"FPNT1","N",10,0},{"GPNT1","N",10,0}})
IF MEMOREAD(RFILE+".1") == MEMOREAD(RFILE+".2")
        PRIVATE RET := .T.
ELSE
        PRIVATE RET := .F.
ENDIF
CLOSE DATABASE
IF !EMPTY(NAMEDBF[1])
        USE (NAMEDBF[1])
        GO (NAMEDBF[2])
ENDIF
FERASE(RFILE+".1")
FERASE(RFILE+".2")
RETURN RET
*/
RETURN .T.

*********************************FUNCION PNTCONT******************************
*DEVUELVE UN ARRAY CON EL CONTENIDO DE UN ARCHIVO BINARIO (.PNT) CREADO POR
*PANTS SEQUENCE.
******************************************************************************

FUNCTION PNTCONT
PARAMETERS FILEPNT, PNTFC
IF EMPTY(FILEPNT)
PARAERROR("PNTCONT()")
ENDIF
IF EMPTY(PNTFC) .OR. VALTYPE(PNTFC) != "B"
PRIVATE PNTFC := {|| NULL()}
ENDIF
IF ALLTRIM(UPPER(ALIAS())) == ALLTRIM(UPPER(FILEPNT))
        ? CHR(7)
        ALERT("Error in the net: the file is in use.",{"QUIT"})
        ERROR(2)
ENDIF

IF !PNTFORM(FILEPNT)
        ? CHR(7)
        ALERT("Error in the file: Is not the correct format.",{"QUIT"})
        ERROR(2)
ENDIF

PRIVATE STIME := SEC_TIME()
PRIVATE NAMEDBF := {ALIAS(),RECNO()}
USE (FILEPNT)
GO TOP
PRIVATE PNTSN1 := 1
PRIVATE PNTSLN := RECCOUNT()
PRIVATE PNTARRAY := {}
DBEVAL({|| PNTSCONT()},,{|| IF(RECNO() <= 4096,.T.,.F.)})
CLOSE DATABASE
IF !EMPTY(NAMEDBF[1])
        USE (NAMEDBF[1])
        GO (NAMEDBF[2])
ENDIF
RETURN PNTARRAY

*********************************FUNCION VIDEODISP****************************
*EJECUTA EL ARRAY DEVUELTO POR PNTCONT().
******************************************************************************

FUNCTION VIDEODISP
PARAMETERS FDISP, CDISP, ADISP, AVMODE, INI, FIN, INK
IF ADISP = NIL
PARAERROR("VIDEODISP()")
ENDIF
IF EMPTY(ADISP) .OR. VALTYPE(ADISP) != "A"
RETURN NIL
ENDIF
PRIVATE FDISP := TYPE_TO(FDISP,0)
PRIVATE CDISP := TYPE_TO(CDISP,0)
PRIVATE INI := TYPE_TO(INI,0)
PRIVATE FIN := TYPE_TO(FIN,0)
PRIVATE INK := TYPE_TO(INK,0)
IF EMPTY(FDISP)
PRIVATE FDISP := 0
ENDIF
IF EMPTY(CDISP)
PRIVATE CDISP := 0
ENDIF
IF EMPTY(AVMODE) .OR. VALTYPE(AVMODE) != "A"
PRIVATE AVMODE[2]
ENDIF
IF EMPTY(INI)
PRIVATE INI := 1
ENDIF
IF EMPTY(FIN)
PRIVATE FIN := LEN(ADISP)-INI+1
ENDIF
IF INI <= 0
PRIVATE INI := 1
ENDIF
IF FIN <= 0
PRIVATE FIN := 1
ENDIF
PRIVATE FIN := INI+FIN-1
IF EMPTY(INK)
PRIVATE INK := 0
ENDIF
IF FIN >= LEN(ADISP)
PRIVATE FIN := LEN(ADISP)
ENDIF
IF INI >= LEN(ADISP)
PRIVATE INI := LEN(ADISP)
ENDIF
FOR I := INI TO FIN
PRIVATE AVMODEb := ACLONE(AVMODE)
        IF EMPTY(AVMODEb[1])
                AVMODEb[1] := ADISP[I][6] + 1
        ENDIF
        IF EMPTY(AVMODEb[2])
                AVMODEb[2] := ADISP[I][7] + 1
        ENDIF

        IF AVMODEb[1] != (MAXROW()+1)
                SETMODE(AVMODEb[1],MAXCOL()+1)
        ENDIF
        IF AVMODEb[2] != (MAXCOL()+1)
                SETMODE(MAXROW()+1,AVMODEb[2])
        ENDIF
RESTSCREEN(ADISP[I][1]+FDISP,ADISP[I][2]+CDISP,ADISP[I][3]+FDISP,ADISP[I][4]+CDISP,ADISP[I][5])
PAUSA01(INK,.F.)
NEXT
RETURN NIL

*********************************FUNCION PNTSAVE******************************
*GUARDA EN UN ARCHIVO .PNT UN ARRAY DEVUELTO POR PNTCONT().
******************************************************************************

FUNCTION PNTSAVE
PARAMETERS SAVEFILE, PNTARRAY, PNTFC
PRIVATE SAVEFILE := TYPE_TO(SAVEFILE)
IF EMPTY(PNTARRAY) .OR. EMPTY(SAVEFILE)
PARAERROR("PNTSAVE()")
ENDIF
IF EMPTY(PNTFC) .OR. VALTYPE(PNTFC) != "B"
PRIVATE PNTFC := {|| NULL()}
ENDIF
IF ALLTRIM(UPPER(ALIAS())) == ALLTRIM(UPPER(SAVEFILE))
        ? CHR(7)
        ALERT("Error in the net: the file is in use.",{"QUIT"})
        ERROR(2)
ENDIF
DBCREATE(SAVEFILE,{{"APNT1","N",10,0},{"BPNT1","N",10,0},{"CPNT1","N",10,0},{"DPNT1","N",10,0},{"EPNT1","C",860,0},{"EPNT2","C",860,0},{"EPNT3","C",860,0},{"EPNT4","C",860,0},{"EPNT5","C",860,0},{"EPNT6","C",860,0},{"EPNT7","C",860,0},{"EPNT8","C",860,0},{"FPNT1","N",10,0},{"GPNT1","N",10,0}})
PRIVATE PNTSN1 := 1
PRIVATE PNTSLN := LEN(PNTARRAY)
PRIVATE STIME := SEC_TIME()
AEVAL(PNTARRAY,{|A| PNTSASE(A)})
RETURN NIL

*********************************FUNCION ANYTOPNT*****************************
*DEVUELVE EL CONTENIDO DE UN ARCHIVO DE TEXTO EN FORMATO DE PANTS SEQUENCE.
******************************************************************************

FUNCTION ANYTOPNT
PARAMETERS FILEPNT, PNTFC, CLRSCR
IF EMPTY(FILEPNT)
PARAERROR("ANYTOPNT()")
ENDIF
IF EMPTY(PNTFC) .OR. VALTYPE(PNTFC) != "B"
PRIVATE PNTFC := {|| NULL()}
ENDIF
IF EMPTY(CLRSCR)
PRIVATE CLRSCR := "W/N"
ENDIF

IF ALLTRIM(UPPER(ALIAS())) == ALLTRIM(UPPER(FILEPNT))
        ? CHR(7)
        ALERT("Error in the net: the file is in use.",{"QUIT"})
        ERROR(2)
ENDIF

IF PNTFORM(FILEPNT)
        ? CHR(7)
        ALERT("Error in the file: The file is in Pants Sequence format, is not need be converted.",{"QUIT"})
        ERROR(2)
ENDIF

PRIVATE STIME := SEC_TIME()
PRIVATE ANYPNT := RTRIM(MEMOREAD(FILEPNT))
PRIVATE PNTSLN := MLCOUNT(ANYPNT,80,4,.T.)
PRIVATE PNTSLN1 := (PNTSLN/42)
PRIVATE PNTSN1 := 1
PRIVATE PNTCONV := {}
FOR PNTSN2 := 1 TO PNTSLN
        IF LEN(PNTCONV) <= 4096
                ANYTOPNTS(CLRSCR)
        ELSE
                EXIT
        ENDIF
NEXT
RETURN PNTCONV

*********************************FUNCION PNTTOTXT*****************************
*GUARDA COMO UN ARCHIVO DE TEXTO EL ARRAY DEVUELTO POR PNTCONT().
******************************************************************************

FUNCTION PNTTOTXT
PARAMETERS SAVEFILE, PNTARRAY, PNTFC
PRIVATE SAVEFILE := TYPE_TO(SAVEFILE)
IF EMPTY(PNTARRAY) .OR. EMPTY(SAVEFILE)
PARAERROR("PNTSAVE()")
ENDIF
IF EMPTY(PNTFC) .OR. VALTYPE(PNTFC) != "B"
PRIVATE PNTFC := {|| NULL()}
ENDIF
IF ALLTRIM(UPPER(ALIAS())) == ALLTRIM(UPPER(SAVEFILE))
        ? CHR(7)
        ALERT("Error in the net: the file is in use.",{"QUIT"})
        ERROR(2)
ENDIF
PRIVATE HNDTXT := FCREATE(SAVEFILE)
PRIVATE PNTSN1 := 1
PRIVATE PNTSLN := LEN(PNTARRAY)
PRIVATE STIME := SEC_TIME()
AEVAL(PNTARRAY,{|A| PNTTXT(A)})
FCLOSE(HNDTXT)
RETURN NIL

*********************************FUNCION EXOMI********************************
*DEVUELVE EL NOMBRE DE ARCHIVO ESPECIFICADO CON UNA EXTENSION POR OMISION.
******************************************************************************

FUNCTION EXOMI
PARAMETERS EXFILE, OMIEX
IF EMPTY(EXFILE)
PRIVATE EXFILE := "*"
ENDIF
IF EMPTY(OMIEX)
PRIVATE OMIEX := EXTRAER(EXFILE,".",2)
ENDIF
PRIVATE EXFILE := RIGHTDEL(SOLO_RUTA(EXFILE),"\") + IF(!EMPTY(SOLO_RUTA(EXFILE)),"\","") + FILE_NAME(EXFILE)
PRIVATE OMIEX := SBSTR(CARTRIM(IF(!EMPTY(AT(".",OMIEX)),EXTRAER(OMIEX,".",2),OMIEX)),1,3)
PRIVATE OMIFILE := EXFILE
IF EMPTY(EXTRAER(EXFILE,".",2)) .AND. EMPTY(AT("*",OMIEX))
        PRIVATE OMIFILE := IF(!EMPTY(AT(".",EXFILE)),EXTRAER(EXFILE,".",1),EXFILE) + "." + OMIEX
ENDIF
RETURN OMIFILE

*********************************FUNCION WINBOX_01****************************
*CAJA CON DISE•O NUMERO UNO.
******************************************************************************

FUNCTION WINBOX_01
PARAMETERS FROW1, FCOL1, FROW2, FCOL2, SN4
IF EMPTY(FROW1)
        PRIVATE FROW1 := 0
ENDIF
IF EMPTY(FCOL1)
        PRIVATE FCOL1 := 0
ENDIF
IF EMPTY(FROW2)
        PRIVATE FROW2 := 0
ENDIF
IF EMPTY(FCOL2)
        PRIVATE FCOL2 := 0
ENDIF
IF EMPTY(SN4)
        PRIVATE SN4 := 1
ENDIF

PRIVATE FARRAY := {"|","/","ƒ","\"}
PRIVATE SN3 := INT(SN4)
FOR SN1 := FROW1 TO FROW2
IF SN3 < 1
        PRIVATE SN3 := 1
ENDIF
IF SN3 > 4
        PRIVATE SN3 := 4
ENDIF
        FOR SN2 := FCOL1 TO FCOL2
                @SN1,SN2 SAY FARRAY[SN3++]
                IF SN3 > 4
                        PRIVATE SN3 := 1
                ENDIF
        NEXT
NEXT
RETURN NIL

*********************************FUNCION DBREGDEL*****************************
*BORRA EL REGISTRO EN CURSO DEL AREA DE TRABAJO.
******************************************************************************

FUNCTION DBREGDEL
DELETE
PACK
RETURN NIL

*********************************FUNCION DBREMPTY*****************************
*DETERMINAR SI EL REGISTRO EN CURSO ESTA VACIO.
******************************************************************************

FUNCTION DBREMPTY
PRIVATE DBSTRC := DBSTRUCT()
PRIVATE nFC := 0
AEVAL(DBSTRC,{|x| IF(EMPTY(&(x[1])),nFC++,.F.)})
PRIVATE EMPREG := .F.
IF nFC >= FCOUNT()
        PRIVATE EMPREG := .T.
ENDIF
RETURN EMPREG

*********************************FUNCION FMASTER******************************
*DEVUELVE EL NOMBRE DE LA PRIMERA FUNCION DE LA PILA DE ACTIVACIONES
*DE CLIPPER.
******************************************************************************

FUNCTION FMASTER
PRIVATE fMAST := 0
DO WHILE !EMPTY(PROCNAME(fMAST))
(fMAST++)
ENDDO
RETURN PROCNAME(fMAST-1)

*********************************STATIC FUNCTIONS****************************************

**********FUNCION ESTATICA PARAERROR***********************
*DA AVISO DE QUE FALTAN PARAMETROS.
***********************************************

STATIC FUNCTION PARAERROR
PARAMETERS FUN
TONE(523,9)
ALERT("ERROR EN FUNCION "+FUN+". FALTAN PARµMETROS.",{"QUIT"})
ERROR(3)
RETURN NIL

**********FUNCION ESTATICA SCOPY ***********************
*COPIA UNA LISTA DE ARCHIVOS ESPECIFICADOS EN UNA VARIABLE.
***********************************************************

STATIC FUNCTION SCOPY
PARAMETERS LISTA_ARCH, RUTA_SAL, CLASE, FILA1, COLUMNA1, RUTA_ENT


PRIVATE LISTA_ARCH := RUTA_ENT+"\"+LISTA_ARCH

IF CLASE = "ARCHIVO"
PRIVATE RUTA_SAL1 := RUTA_SAL

ELSE

PRIVATE RUTA_SAL1 := ALLTRIM(RUTA_SAL+"\"+FILE_NAME(LISTA_ARCH))
        IF SUBSTR(RUTA_SAL1,LEN(RUTA_SAL1)-1,LEN(RUTA_SAL1)) = "\"
        PRIVATE RUTA_SAL1 := STUFF(RUTA_SAL1,LEN(RUTA_SAL1)-1,LEN(RUTA_SAL1),"")
        ENDIF
ENDIF

PRIVATE FILA := FILA1
PRIVATE COLUMNA := COLUMNA1

PRIVATE COLOR_ANT := SETCOLOR()
SETCOLOR(EXTRAER(SETCOLOR(),",",1)+"*")
@FILA,COLUMNA SAY LISTA_ARCH
        IF ISWRITE(RUTA_SAL1) .AND. FILE(LISTA_ARCH)
        COPY FILE &LISTA_ARCH TO &RUTA_SAL1
        ENDIF
SETCOLOR(COLOR_ANT)
SETCOLOR(EXTRAER(SETCOLOR(),",",1)+"+")
@FILA,COLUMNA SAY LISTA_ARCH
KEYPAUSE(0.05,.T.,.F.)
@FILA,COLUMNA CLEAR TO FILA,COLUMNA+LEN(LISTA_ARCH)
SETCOLOR(COLOR_ANT)
SETPOS(ROW()+1,COL())
RETURN NIL

**********FUNCION ESTATICA __CURINS *************************
*CAMBIA LA MODALIDAD DE INSERCION.
***********************************************************

FUNCTION __CURINS
PARAMETERS CURzOR
IF !READINSERT()
READINSERT(.T.)
ELSE
READINSERT(.F.)
ENDIF
IF !EMPTY(SETCURSOR())
        DO CASE
                CASE !READINSERT()
                        SETCURSOR(CURzOR[1])
                CASE READINSERT()
                        SETCURSOR(CURzOR[2])
        ENDCASE
ENDIF
RETURN NIL

**********FUNCION ESTATICA SALIR **************************
*SALE DE LA APLICACI‡N.
***********************************************************

STATIC FUNCTION SALIR
KEYSTUFF(23)
RETURN NIL

**********FUNCIONES ESTATICAS DE NUM_CAR *****************************************
*TODAS JUNTAS CONVIERTEN UN NUMERO A PALABRAS.
********************************************************************************

**********FUNCION ESTATICA UNIDAD ***********************
*CONVIERTE EL 1ß DIGITO DE UN NUMERO A PALABRAS.
***********************************************************

STATIC FUNCTION UNIDAD
PARAMETERS DIGITO
PRIVATE PALABRA := ""
DO CASE
        CASE DIGITO = "1"
        PRIVATE PALABRA := " MAS UNO"

        CASE DIGITO = "2"
        PRIVATE PALABRA := " MAS DOS"

        CASE DIGITO = "3"
        PRIVATE PALABRA := " MAS TRES"

        CASE DIGITO = "4"
        PRIVATE PALABRA := " MAS CUATRO"

        CASE DIGITO = "5"
        PRIVATE PALABRA := " MAS CINCO"

        CASE DIGITO = "6"
        PRIVATE PALABRA := " MAS SEIS"

        CASE DIGITO = "7"
        PRIVATE PALABRA := " MAS SIETE"

        CASE DIGITO = "8"
        PRIVATE PALABRA := " MAS OCHO"

        CASE DIGITO = "9"
        PRIVATE PALABRA := " MAS NUEVE"

        CASE DIGITO = "0"
        PRIVATE PALABRA := ""

ENDCASE

RETURN PALABRA

**********FUNCION ESTATICA DECENA ***********************
*CONVIERTE EL 2ß DIGITO DE UN NUMERO A PALABRAS.
*********************************************************

STATIC FUNCTION DECENA
PARAMETERS DIGITO
PRIVATE PALABRA := ""
DO CASE
        CASE DIGITO = "1"
        PRIVATE PALABRA := " MAS DIEZ"

        CASE DIGITO = "2"
        PRIVATE PALABRA := " MAS VEINTE"

        CASE DIGITO = "3"
        PRIVATE PALABRA := " MAS TREINTA"

        CASE DIGITO = "4"
        PRIVATE PALABRA := " MAS CUARENTA"

        CASE DIGITO = "5"
        PRIVATE PALABRA := " MAS CINCUENTA"

        CASE DIGITO = "6"
        PRIVATE PALABRA := " MAS SESENTA"

        CASE DIGITO = "7"
        PRIVATE PALABRA := " MAS SETENTA"

        CASE DIGITO = "8"
        PRIVATE PALABRA := " MAS OCHENTA"

        CASE DIGITO = "9"
        PRIVATE PALABRA := " MAS NOVENTA"

        CASE DIGITO = "0"
        PRIVATE PALABRA := ""

ENDCASE

RETURN PALABRA

**********FUNCION ESTATICA CENTENA ***********************
*CONVIERTE EL 3ß DIGITO DE UN NUMERO A PALABRAS.
***********************************************************

STATIC FUNCTION CENTENA
PARAMETERS DIGITO
PRIVATE PALABRA := ""
DO CASE
        CASE DIGITO = "1"
        PRIVATE PALABRA := " MAS CIEN"

        CASE DIGITO = "2"
        PRIVATE PALABRA := " MAS DOSCIENTOS"

        CASE DIGITO = "3"
        PRIVATE PALABRA := " MAS TRESCIENTOS"

        CASE DIGITO = "4"
        PRIVATE PALABRA := " MAS CUATROCIENTOS"

        CASE DIGITO = "5"
        PRIVATE PALABRA := " MAS QUINIENTOS"

        CASE DIGITO = "6"
        PRIVATE PALABRA := " MAS SEISCIENTOS"

        CASE DIGITO = "7"
        PRIVATE PALABRA := " MAS SETECIENTOS"

        CASE DIGITO = "8"
        PRIVATE PALABRA := " MAS OCHOCIENTOS"

        CASE DIGITO = "9"
        PRIVATE PALABRA := " MAS NOVECIENTOS"

        CASE DIGITO = "0"
        PRIVATE PALABRA := ""

ENDCASE

RETURN PALABRA

**********FUNCION ESTATICA UNI_DE_MIL ***********************
*CONVIERTE EL 4ß DIGITO DE UN NUMERO A PALABRAS.
***********************************************************

STATIC FUNCTION UNI_DE_MIL
PARAMETERS DIGITO
PRIVATE PALABRA := ""
DO CASE
        CASE DIGITO = "1"
        PRIVATE PALABRA := " MAS MIL"

        CASE DIGITO = "2"
        PRIVATE PALABRA := " MAS DOS MIL"

        CASE DIGITO = "3"
        PRIVATE PALABRA := " MAS TRES MIL"

        CASE DIGITO = "4"
        PRIVATE PALABRA := " MAS CUATRO MIL"

        CASE DIGITO = "5"
        PRIVATE PALABRA := " MAS CINCO MIL"

        CASE DIGITO = "6"
        PRIVATE PALABRA := " MAS SEIS MIL"

        CASE DIGITO = "7"
        PRIVATE PALABRA := " MAS SIETE MIL"

        CASE DIGITO = "8"
        PRIVATE PALABRA := " MAS OCHO MIL"

        CASE DIGITO = "9"
        PRIVATE PALABRA := " MAS NUEVE MIL"

        CASE DIGITO = "0"
        PRIVATE PALABRA := ""

ENDCASE

RETURN PALABRA

**************************************FUNCION ESTATICA MENU*******************
*AGREGA ARCHIVOS AL MENU.
******************************************************************************

STATIC FUNCTION MENU
PARAMETERS ARCH
AADD(MENU_AR,ARCH)
RETURN NIL

************************************FUNCION ESTATICA WIND*********************
*LIMPIA UN TROZO DE LA PANTALLA CON UNA VELOCIDAD DETERMINADA.
******************************************************************************

STATIC FUNCTION WIND
PARAMETERS A,B,X,Y,VEL,BOX_CAR
IF VEL = NIL
PRIVATE VEL := 8
ENDIF
IF BOX_CAR = NIL
PRIVATE BOX_CAR := ""
ENDIF

PRIVATE CV := (X + A)/2
PRIVATE CH := (Y + B)/2

PRIVATE H := (Y - B)/VEL
PRIVATE V := (X - A)/VEL

PRIVATE Q := 0
DO WHILE Q <= VEL
     @ ROUND(CV - V*Q,0), ROUND(CH - H*Q,0), ROUND(CV + V*Q,0), ROUND(CH + H*Q,0) BOX BOX_CAR
PRIVATE Q := Q + 1
ENDDO
RETURN NIL
***********************************

*****************************FUNCION ESTATICA MURALLA*************************
*DIBUJA UNA MURALLA EN LA PANTALLA
******************************************************************************

STATIC FUNCTION MURALLA
CLEAR
PRIVATE FI := 0
PRIVATE REPLI := SUBSTR(REPLICATE(CHR(449)+CHR(196)+CHR(450)+CHR(196),MAXCOL()),1,MAXCOL()+1)
DO WHILE FI <= MAXROW()
@FI,0 SAY REPLI
PRIVATE FI := FI + 2
ENDDO
PRIVATE FI := 1
PRIVATE REPLI2 := SUBSTR(REPLICATE(CHR(450)+CHR(196)+CHR(449)+CHR(196),MAXCOL()),1,MAXCOL()+1)
DO WHILE FI <= MAXROW()
@FI,0 SAY REPLI2
PRIVATE FI := FI + 2
ENDDO
RETURN NIL
**********************


*********************FUNCION ESTATICA ISTEXTKEY******************************
STATIC FUNCTION ISTEXTKEY
PRIVATE LOGRO := .F.

IF LASTKEY() = 5
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 24
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 19
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 4
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 7
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 13
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 27
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 1
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 6
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 18
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 3
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 26
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 2
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 29
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 23
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 31
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 30
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 10
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 3
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 8
PRIVATE LOGRO := .T.
ENDIF

IF LASTKEY() = 22
PRIVATE LOGRO := .T.
ENDIF

RETURN LOGRO
********************

***************************FUNCION ESTATICA RSET******************************
*RESTAURA UN SET.
******************************************************************************

STATIC FUNCTION RSET
PARAMETERS S1, N
SET(N,S1)
PRIVATE NUM := NUM + 1
RETURN NIL

***************************FUNCION ESTATICA SKEY******************************
*RESTAURA UNA TECLA.
******************************************************************************

STATIC FUNCTION SKEY
PARAMETERS NUM1, KEYM1
        IF KEYM1 != NIL
        SETKEY(NUM1,KEYM1)
        ELSE
        SET KEY NUM1 TO
        ENDIF
PRIVATE NUM := NUM + 1
RETURN NIL

***************************FUNCION ESTATICA TO_STR****************************
*CONVIERTE UN VALOR DE CUALQUIER TIPO A UN VALOR CARACTER.
******************************************************************************

STATIC FUNCTION TO_STR
PARAMETERS VALOR
IF VALTYPE(VALOR) != "A" .AND. VALTYPE(VALOR) != "B"
PRIVATE VALOR2 := TRANSFORM(VALOR,"")
ENDIF
IF VALTYPE(VALOR) = "A"
PRIVATE VALOR2 := "MATRIZ"
ENDIF
IF VALTYPE(VALOR) = "B"
PRIVATE VALOR2 := "BLOQUE"
ENDIF
RETURN VALOR2

***************************FUNCION ESTATICA NULO__******************************
*FUNCION NULA.
******************************************************************************

FUNCTION NULO__
RETURN NIL

***************************FUNCION ESTATICA MELODY__**************************
*TOCA UN TONO SEGUN LA ULTIMA TECLA PULSADA.
******************************************************************************

FUNCTION MELODY__
PRIVATE LASTKEY := LASTKEY()
PRIVATE LASTKEY := ASC(UPPER(CHR(LASTKEY)))
DO CASE
        CASE LASTKEY = 65
        *DO (C)
        TONE(130.80)

        CASE LASTKEY = 66
        *DO# (C#)
        TONE(138.60)

        CASE LASTKEY = 67
        *RE (D)
        TONE(146.80)

        CASE LASTKEY = 68
        *RE# (D#)
        TONE(155.60)

        CASE LASTKEY = 69
        *MI (E)
        TONE(164.80)

        CASE LASTKEY = 70
        *FA (F)
        TONE(174.60)

        CASE LASTKEY = 71
        *FA# (F#)
        TONE(185.00)

        CASE LASTKEY = 72
        *SOL (G)
        TONE(196.00)

        CASE LASTKEY = 73
        *SOL# (G#)
        TONE(207.70)

        CASE LASTKEY = 74
        *LA (A)
        TONE(220.00)

        CASE LASTKEY = 75
        *LA# (A#)
        TONE(233.10)

        CASE LASTKEY = 76
        *SI (B)
        TONE(246.90)

        CASE LASTKEY = 77
        *DO (mid C)
        TONE(261.70)

        CASE LASTKEY = 78
        *DO# (C#)
        TONE(277.20)

        CASE LASTKEY = 79
        *RE (D)
        TONE(293.70)

        CASE LASTKEY = 80
        *RE# (D#)
        TONE(311.10)

        CASE LASTKEY = 81
        *MI (E)
        TONE(329.60)

        CASE LASTKEY = 82
        *FA (F)
        TONE(349.20)

        CASE LASTKEY = 83
        *FA# (F#)
        TONE(370.00)

        CASE LASTKEY = 84
        *SOL (G)
        TONE(392.00)

        CASE LASTKEY = 85
        *SOL# (G#)
        TONE(415.30)

        CASE LASTKEY = 86
        *LA (A)
        TONE(440.00)

        CASE LASTKEY = 87
        *LA# (A#)
        TONE(466.20)

        CASE LASTKEY = 88
        *SI (B)
        TONE(493.90)

        CASE LASTKEY = 89
        *DO (C)
        TONE(523.30)
ENDCASE
RETURN NIL

***************************FUNCION ESTATICA SUP_SCR***************************
*SUPRIME UN TROZO DE LA PANTALLA.
******************************************************************************

STATIC FUNCTION SUP_SCR
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC
     PRIVATE SCR := SAVESCREEN( FSUP, COLIZQ, FINFI, COLDEREC)
     PRIVATE X := 1
     DO WHILE X < LEN(SCR)
     PRIVATE SCR := STUFF(SCR,X,1," ")
     PRIVATE X := X + 2
     ENDDO
     RESTSCREEN(FSUP, COLIZQ, FINFI, COLDEREC, SCR)
RETURN NIL

***************************FUNCION ESTATICA CAR_NOTA**************************
*INFORMA CUAL ES EL TONO DEL CARACTER ESPECIFICADO SEGUN LAS NOTAS MUSICALES Y
*ORDEN DEL ABECEDARIO.
******************************************************************************

STATIC FUNCTION CAR_NOTA
PARAMETERS C
PRIVATE LASTKEY := ASC(UPPER(C))
DO CASE
        CASE LASTKEY = 65
        *DO (C)
        PRIVATE R := 130.80

        CASE LASTKEY = 66
        *DO# (C#)
        PRIVATE R := 138.60

        CASE LASTKEY = 67
        *RE (D)
        PRIVATE R := 146.80

        CASE LASTKEY = 68
        *RE# (D#)
        PRIVATE R := 155.60

        CASE LASTKEY = 69
        *MI (E)
        PRIVATE R := 164.80
        
        CASE LASTKEY = 70
        *FA (F)
        PRIVATE R := 174.60

        CASE LASTKEY = 71
        *FA# (F#)
        PRIVATE R := 185.00

        CASE LASTKEY = 72
        *SOL (G)
        PRIVATE R := 196.00

        CASE LASTKEY = 73
        *SOL# (G#)
        PRIVATE R := 207.70

        CASE LASTKEY = 74
        *LA (A)
        PRIVATE R := 220.00

        CASE LASTKEY = 75
        *LA# (A#)
        PRIVATE R := 233.10

        CASE LASTKEY = 76
        *SI (B)
        PRIVATE R := 246.90

        CASE LASTKEY = 77
        *DO (mid C)
        PRIVATE R := 261.70

        CASE LASTKEY = 78
        *DO# (C#)
        PRIVATE R := 277.20

        CASE LASTKEY = 79
        *RE (D)
        PRIVATE R := 293.70

        CASE LASTKEY = 80
        *RE# (D#)
        PRIVATE R := 311.10

        CASE LASTKEY = 81
        *MI (E)
        PRIVATE R := 329.60

        CASE LASTKEY = 82
        *FA (F)
        PRIVATE R := 349.20

        CASE LASTKEY = 83
        *FA# (F#)
        PRIVATE R := 370.00

        CASE LASTKEY = 84
        *SOL (G)
        PRIVATE R := 392.00

        CASE LASTKEY = 85
        *SOL# (G#)
        PRIVATE R := 415.30

        CASE LASTKEY = 86
        *LA (A)
        PRIVATE R := 440.00

        CASE LASTKEY = 87
        *LA# (A#)
        PRIVATE R := 466.20

        CASE LASTKEY = 88
        *SI (B)
        PRIVATE R := 493.90

        CASE LASTKEY = 89
        *DO (C)
        PRIVATE R := 523.30

        OTHERWISE
        PRIVATE R := 0
ENDCASE
RETURN R

***************************FUNCION ESTATICA TXT*******************************
*EDITA UN TEXTO DE DESPLIEGUE REPENTINO.
******************************************************************************


STATIC FUNCTION TXT(VAR,ROW,COL)
PRIVATE V := VAR
DO WHILE .T.
COLOR_SAY(V,ROW,COL)
PRIVATE KEY := KEYPAUSE(0,.T.,.F.)
DO CASE
        CASE KEY = 8 .OR. KEY = 19
        PRIVATE V := STUFF(V,LEN(V),1,"")
        COLOR_SAY(SPACE(LEN(V)+1),ROW,COL)
        CASE KEY = 13
        EXIT
        CASE KEY = 27
        COLOR_SAY(SPACE(LEN(V)+1),ROW,COL)
        PRIVATE V := ""
        CASE ISTEXTKEY()
        PRIVATE V := V
        CASE TXTK()
        PRIVATE V := V + CHR(KEY)
ENDCASE
ENDDO
RETURN V

***************************FUNCION ESTATICA TXTK*******************************
*ESPECIFICA SI LA TECLA PULSADA ES UN CARACTER PERMITIDO.
******************************************************************************

STATIC FUNCTION TXTK
IF LASTKEY() >= 1 .AND. LASTKEY() <= 255
RETURN .T.
ELSE
RETURN .F.
ENDIF
RETURN NIL

***************************FUNCION ESTATICA COL_IN****************************
*PINTA UN TROZO DE LA PANTALLA.
******************************************************************************

STATIC FUNCTION COL_IN
PARAMETERS FSUP, COLIZQ, FINFI, COLDEREC

PRIVATE SCR1 := CHARODD(SAVESCREEN(FSUP,COLIZQ,FINFI,COLDEREC))
PRIVATE SCR2 := CHARMIX(SCR1,PADR("",LEN(SCR1),CHR(COLORTON(COLOR_AC))))

RESTSCREEN(FSUP, COLIZQ, FINFI, COLDEREC, SCR2)
RETURN NIL

***************************FUNCION ESTATICA PROMPT_TO*************************
*ACTIVA OPCIONES DE MENBUTTON().
******************************************************************************

STATIC FUNCTION PROMPT_TO(B)
IF LEN(B) < 3
PARAERROR("MENBUTTON()")
ENDIF

IF LEN(B) < 4
AADD(B,"")
ENDIF
IF B[1] = 0
B[1] = 1
ENDIF

IF B[2] = 0
B[2] = 1
ENDIF
SETCOLOR(COLOR_C)
PRIVATE FI2 := B[1]+1
PRIVATE CO2 := B[2]+LEN(B[3])
AADD(WOPMENB,WINDOW_03(B[1]-1,B[2]-1,FI2,CO2,CAD_FRONT,COLOR_A,COLOR_B,COLOR_C))
SETCOLOR(COLOR_A)
DISPBOX(B[1]-1,B[2]-1,FI2,CO2,CAD_FONDO)
SETCOLOR(COLOR_C)
@B[1],B[2] SAY B[3]
RETURN NIL

***************************FUNCION ESTATICA CTXT__****************************
*EL EL TEXTO DE LA CALCULADORA.
******************************************************************************

FUNCTION CTXT__
PRIVATE KEY := LASTKEY()
DO CASE
        CASE KEY = 8
        CT := STUFF(CT,LEN(CT),1,"")
        IF EMPTY(CT)
        CT := "0"
        ENDIF
        OPMENB := 21
        CASE KEY = ASC("=")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))
        OPMENB := 16

        CASE KEY = ASC("/")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))+"/"
        OPMENB := 13

        CASE KEY = ASC("*")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))+"*"
        OPMENB := 14

        CASE KEY = ASC("-")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))+"-"
        OPMENB := 15

        CASE KEY = ASC("+")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))+"+"
        OPMENB := 12

        CASE KEY = ASC("%")
        CT := ALLTRIM(TO_STR(CALCULO(CT)))+"%"
        OPMENB := 19

        CASE KEY = ASC(".") .AND. !UNODEC(CT)
        CT := CT + "."
        OPMENB := 11

        CASE KEY = 27
        CT := "0"

        CASE KEY >= 48 .AND. KEY <= 57 .AND. !ISLEN(CT)
        CT := CT + CHR(KEY)
        OPMENB := 10-VAL(CHR(KEY))

ENDCASE
IF EMPTY(CT)
CT := "0"
ENDIF
@FSUP+2,COLIZQ+2 SAY SUBSTR(TO_RIGHT(PADC(CT,10000," ")),LEN(TO_RIGHT(PADC(CT,10000," ")))-23,LEN(TO_RIGHT(PADC(CT,10000," "))))
RETURN NIL

***************************FUNCION ESTATICA CALC_1****************************
*ES EL MENU DE LA CALCULADORA.
******************************************************************************

STATIC FUNCTION CALC_1
OPCALC := MENBUTTON(ARRAY_M,COLOR_A1,COLOR_B2,COLOR_C3,,REPLICATE(CHR(255),9),OPCALC)
RETURN NIL

***************************FUNCION ESTATICA CALCULO***************************
*EFECTUA EL CALCULO DE UNA EXPRESION.
******************************************************************************

STATIC FUNCTION CALCULO
PARAMETERS CALCULO
DO CASE
        CASE !EMPTY(CALCULO)
                IF ISDIGIT(SUBSTR(ALLTRIM(CALCULO),LEN(ALLTRIM(CALCULO)),1)) .AND. !DOBLEDEC(CALCULO)
                CALCULO := &(CALCULO)
                ELSE
                        IF !ISDIGIT(SUBSTR(ALLTRIM(CALCULO),LEN(ALLTRIM(CALCULO)),1))
                        CALCULO := STUFF(ALLTRIM(CALCULO),LEN(ALLTRIM(CALCULO)),1,"")
                        ENDIF
                ENDIF
        OTHERWISE
        CALCULO := 0
ENDCASE
RETURN CALCULO

***************************FUNCION ESTATICA COUNT*****************************
*CALCULA EL VALOR DE LA VARIABLE "NUM"(ARRAY_NUM()).
******************************************************************************

STATIC FUNCTION COUNT
NUM := NUM + 1
RETURN NIL

***************************FUNCION ESTATICA DOBLEDEC**************************
*VERIFICA SI HAY ALGUN NUMERO CON DOS O MAS PUNTOS DECIMALES ESCRITOS.
******************************************************************************

STATIC FUNCTION DOBLEDEC
PARAMETERS NUMERO
IF NUMERO = NIL
PARAERROR("NUMERO()")
ENDIF
PRIVATE NUMERO := ALLTRIM(NUMERO)
PRIVATE C := 1
PRIVATE W1 := {}
DO WHILE C <= LEN(NUMERO) .AND. LEN(W1) < 4096
PRIVATE W := ""
        DO WHILE ISDIGIT(SUBSTR(NUMERO,C,1)) .OR. SUBSTR(NUMERO,C,1) = "."
        PRIVATE W := W+SUBSTR(NUMERO,C,1)
        PRIVATE C := C + 1
        ENDDO
AADD(W1,W)
PRIVATE C := C + 1
ENDDO
PRIVATE LOGRO := .F.
AEVAL(W1,{|NUM| DD(NUM)})
RETURN LOGRO

***************************FUNCION ESTATICA DD********************************
*FUNCION DE DOBLEDEC().
******************************************************************************

STATIC FUNCTION DD
PARAMETERS N
IF REPITCAR(N,".") > 1
LOGRO := .T.
ENDIF
RETURN NIL

***************************FUNCION ESTATICA MOVECALC**************************
*MUEVE LA CALCULADORA.
******************************************************************************

STATIC FUNCTION MOVECALC
PRIVATE MSK := SAVEKEYS()
KEYS_TO("")
PRIVATE MC := MOVER(FSUP,COLIZQ,FSUP+16,COLIZQ+27)
RESTKEYS(MSK)
FSUP := MC[1]
COLIZQ := MC[2]
KEYSTUFF(27)
RETURN NIL

***************************FUNCION ESTATICA KEYFESC***************************
*SALE DE LA CALCULADORA.
******************************************************************************

STATIC FUNCTION KEYFESC
KEYSTUFF(6)
KEYSTUFF(13)
RETURN NIL

***************************FUNCION ESTATICA UNODEC****************************
*VERIFICA SI HAY ALGUN NUMERO CON DOS O MAS PUNTOS DECIMALES ESCRITOS.
******************************************************************************

STATIC FUNCTION UNODEC
PARAMETERS NUMERO
IF NUMERO = NIL
PARAERROR("NUMERO()")
ENDIF
PRIVATE NUMERO := ALLTRIM(NUMERO)
PRIVATE C := 1
PRIVATE W1 := {}
DO WHILE C <= LEN(NUMERO) .AND. LEN(W1) < 4096
PRIVATE W := ""
        DO WHILE ISDIGIT(SUBSTR(NUMERO,C,1)) .OR. SUBSTR(NUMERO,C,1) = "."
        PRIVATE W := W+SUBSTR(NUMERO,C,1)
        PRIVATE C := C + 1
        ENDDO
AADD(W1,W)
PRIVATE C := C + 1
ENDDO
IF REPITCAR(W1[ACOUNT(W1)],".") >= 1
PRIVATE LOGRO := .T.
ELSE
PRIVATE LOGRO := .F.
ENDIF
RETURN LOGRO

***************************FUNCION ESTATICA SBSTR*****************************
*EXTRAE UNA SUBCADENA DE CARACTERES.
******************************************************************************

FUNCTION SBSTR
PARAMETERS VAR, INICIO, FIN
IF INICIO <= 0
PRIVATE INICIO := 1
ENDIF
IF (FIN+INICIO-1) > LEN(VAR)
PRIVATE FIN := FIN-((FIN+INICIO-1)-LEN(VAR))
ENDIF
RETURN SUBSTR(VAR,INICIO,FIN)

***************************FUNCION ESTATICA ISCONFIRM*************************
*INDICA SI EL SET CONFIRM ESTA ON O ESTA OFF.
******************************************************************************

FUNCTION ISCONFIRM
RETURN SET(_SET_CONFIRM)

***************************FUNCION ESTATICA ISLEN*****************************
*INDICA SI EXISTEN MAS DE 16 DIGITOS EN ALGUN NUMERO DE LA CALCULADORA.
******************************************************************************

STATIC FUNCTION ISLEN
PARAMETERS NUMERO
IF NUMERO = NIL
PARAERROR("ISLEN()")
ENDIF
PRIVATE NUMERO := ALLTRIM(NUMERO)
PRIVATE C := 1
PRIVATE W1 := {}
DO WHILE C <= LEN(NUMERO) .AND. LEN(W1) < 4096
PRIVATE W := ""
        DO WHILE ISDIGIT(SUBSTR(NUMERO,C,1)) .OR. SUBSTR(NUMERO,C,1) = "."
        PRIVATE W := W+SUBSTR(NUMERO,C,1)
        PRIVATE C := C + 1
        ENDDO
AADD(W1,W)
PRIVATE C := C + 1
ENDDO
IF LEN(W1[ACOUNT(W1)]) >= 16 .AND. ISDIGIT(SUBSTR(ALLTRIM(NUMERO),LEN(ALLTRIM(NUMERO)),1))
PRIVATE LOGRO := .T.
ELSE
PRIVATE LOGRO := .F.
ENDIF
RETURN LOGRO

***************************FUNCION ESTATICA TRADUC****************************
*FUNCION DE TRADUCTOR().
******************************************************************************

STATIC FUNCTION TRADUC
PARAMETERS LENGUAJE1,LENGUAJE2
CHARACTER := DELSTUFF(CHARACTER,LENGUAJE1,LENGUAJE2[N])
N := N + 1
RETURN NIL

***************************FUNCION ESTATICA OPENWRIT**************************
*ESCRIBE AL FINAL DE UN ARCHIVO BINARIO.
******************************************************************************

STATIC FUNCTION OPENWRIT
PARAMETERS ARCH, STRING
PRIVATE HANDLE := FOPEN(ARCH,2)
FSEEK(HANDLE,0,2)
FWRITE(HANDLE,STRING)
FCLOSE(HANDLE)
RETURN NIL

***************************FUNCION ESTATICA ADEP******************************
*FUNCION DE ARRAY_DEP().
******************************************************************************

STATIC FUNCTION ADEP
PARAMETERS ADEP
IF !EMPTY(ADEP)
AADD(ARRAY2,ADEP)
ENDIF
RETURN NIL

***************************FUNCION ESTATICA ARRAY_UP**************************
*DEVUELVE UN ARRAY CON TODOS SUS ELEMENTOS EN LETRA MAYUSCULA.
******************************************************************************

STATIC FUNCTION ARRAY_UP
PARAMETERS ARRAY_UP
PRIVATE ARRAY_UP2 := {}
AEVAL(ARRAY_UP,{|R| A_UP(R)})
RETURN ARRAY_UP2

***************************FUNCION ESTATICA A_UP******************************
*FUNCION DE ARRAY_UP().
******************************************************************************

STATIC FUNCTION A_UP
PARAMETERS A_UP
AADD(ARRAY_UP2,UPPER(A_UP))
RETURN NIL

***************************FUNCION ESTATICA ASBSTR****************************
*ES IGUAL QUE SUBSTR PERO PARA UN ARRAY.
******************************************************************************

STATIC FUNCTION ASBSTR
PARAMETERS ARRAY, LONG
PRIVATE ARRAY2 := {}
AEVAL(ARRAY,{|A| ALONG(A,LONG)})
RETURN ARRAY2

***************************FUNCION ESTATICA ALONG*****************************
*FUNCION DE ASBSTR().
******************************************************************************

STATIC FUNCTION ALONG
PARAMETERS A1,L
AADD(ARRAY2,SBSTR(A1,1,L))
RETURN NIL

***************************FUNCION ESTATICA DOSETKEY**************************
*EJECUTA EL BLOQUE DE CODIGO ASIGNADO A UNA TECLA.
******************************************************************************

STATIC FUNCTION DOSETKEY
PARAMETERS K
PRIVATE K1 := SETKEY(K)
IF VALTYPE(K1) = "B"
EVAL(K1,PROCNAME(1),PROCLINE(1),READVAR())
ENDIF
RETURN NIL

***************************FUNCION ESTATICA DIRADD****************************
*AGREGA UN DIRECTORIO A LA MATRIZ DE SUBPATH().
******************************************************************************

STATIC FUNCTION DIRADD
PARAMETERS DADD
PRIVATE SETEXACT := SET(_SET_EXACT)
SET EXACT ON
IF DADD[5] = "D" .AND. ALLTRIM(DADD[1]) != CHR(46)
        AADD(RUTA1,DADD[1])
ENDIF
SET(_SET_EXACT,SETEXACT)
RETURN NIL

***************************FUNCION ESTATICA DELDRIVE**************************
*BORRA LA UNIDAD DE LA RUTA DE ACCESO.
******************************************************************************

STATIC FUNCTION DELDRIVE
PARAMETERS D_DRIVE
PRIVATE SEXACT := SET(_SET_EXACT)
SET EXACT OFF
PRIVATE D_DRIVE := UPPER(ALLTRIM(D_DRIVE))
IF AT(DRIVE(D_DRIVE)+":\",D_DRIVE) = 1
        PRIVATE D_DRIVE := CARTRIM(D_DRIVE,DRIVE(D_DRIVE)+":\")
ELSE
DO CASE
        CASE AT(DRIVE(D_DRIVE)+":",D_DRIVE) != 0
                PRIVATE D_DRIVE := CARTRIM(D_DRIVE,DRIVE(D_DRIVE)+":")
                PRIVATE D_DRIVE := CURDIR()+"\"+LEFTDEL(RIGHTDEL(D_DRIVE,"\"),"\")
        CASE SBSTR(D_DRIVE,1,1) != "\"
                PRIVATE D_DRIVE := CURDIR()+"\"+LEFTDEL(RIGHTDEL(D_DRIVE,"\"),"\")
ENDCASE
ENDIF
SET(_SET_EXACT,SEXACT)
RETURN D_DRIVE

***************************FUNCION ESTATICA ARRAYDRIVE************************
*DEVUELVE UN ARRAY CON TODAS LAS UNIDADES DE SISTEMA.
******************************************************************************

STATIC FUNCTION ARRAYDRIVE
PRIVATE DR := {}
FOR D := 1 TO 27
AADD(DR,TO_NUMBER(D)+":\")
NEXT
RETURN DR

***************************FUNCION ESTATICA PRMPT_TO*************************
*ACTIVA OPCIONES DE BOXMENU().
******************************************************************************

STATIC FUNCTION PRMPT_TO(B)
IF LEN(B) < 4
PARAERROR("BOXMENU()")
ENDIF

IF LEN(B) < 5
AADD(B,"")
ENDIF

SETCOLOR(COLOR_A)
DISPBOX(B[1]-1,B[2]-1,B[3]+1,B[4]+1,CAD_FONDO)
SETCOLOR(COLOR_C)
COLOR_IN(B[1],B[2],B[3],B[4],COLOR_C)
AADD(SCRVARS,{B[1],B[2],B[3],B[4],SAVESCREEN(B[1],B[2],B[3],B[4])})
RETURN NIL

***************************FUNCION ESTATICA MVAL******************************
*FUNCION DE MAXVAL().
******************************************************************************

STATIC FUNCTION MVAL
PARAMETERS MV
IF VALTYPE(MV) != VALTYPE(MVAL)
RETURN NIL
ENDIF
MVAL := MAX(MVAL,MV)
RETURN NIL

***************************FUNCION ESTATICA MVAL1*****************************
*FUNCION DE MINVAL().
******************************************************************************

STATIC FUNCTION MVAL1
PARAMETERS MV
IF VALTYPE(MV) != VALTYPE(MVAL1)
RETURN NIL
ENDIF
MVAL1 := MIN(MVAL1,MV)
RETURN NIL

***************************FUNCION ESTATICA ASETFP****************************
*EJECUTA LA FUNCION ESPECIFICADA EN SETFUNCP() DESPUES DE HABER PASADO EL
*TIEMPO ESPECIFICADO EN LA FUNCION DE ESPERA.
******************************************************************************

STATIC FUNCTION ASETFP
PARAMETERS STIME1, STIME2
SETFATTR(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3),0)
IF FILE(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3))
        PRIVATE MSETFP := MEMOREAD(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3))
        IF ((STIME2-STIME1) >= TYPE_TO(ALLTRIM(EXTRAER(MSETFP,",",2)),0)) .AND. (UPPER(FMASTER()) == UPPER(EXTRAER(MSETFP,",",3)))
        PRIVATE SETFUNC := &("{|| "+ALLTRIM(EXTRAER(MSETFP,",",1))+"}")
        EVAL(SETFUNC)
        INICIO1 := SEC_TIME()
        ENDIF
ENDIF
SETFATTR(DISKNAME()+":\SETFP__."+REPLICATE(CHR(255),3),1)
RETURN NIL

***************************FUNCION ESTATICA LENCHAR***************************
*DEVUELVE EL NUMERO CORRESPONDIENTE A LA SUMA DE LOS CARACTERES ASCII DE LA
*VARIABLE.
******************************************************************************

STATIC FUNCTION LENCHAR
PARAMETERS LCHAR
PRIVATE LCH := 0
PRIVATE LCHN := 1
DO WHILE LCHN <= LEN(LCHAR)
PRIVATE LCH := LCH + ASC(SBSTR(LCHAR,LCHN,1))
PRIVATE LCHN := LCHN + 1
ENDDO
RETURN LCH

***************************FUNCION ESTATICA MENUCENTER************************
*PROCESA LAS OPCIONES DADAS POR LA FUNCION CENTER().
******************************************************************************

FUNCTION MENUCENTER
PARAMETERS MNCENT1

IF EMPTY(MNCENT1)
PRIVATE MNCENT1 := {"OK"}
ENDIF

PRIVATE CNT1 := 1
PRIVATE CNT2 := 0

DO WHILE CNT2 <= COVAL .AND. CNT1 <= LEN(MNCENT1)
        PRIVATE CNT2 := CNT2 + LEN(MNCENT1[CNT1])+2
        PRIVATE CNT1 := CNT1 + 1
ENDDO

PRIVATE CNT1 := CNT1-1
PRIVATE MNCENT2 := {}
PRIVATE CNT3 := 1
PRIVATE CNT4 := (C1+(COVAL/2))-(CNT2/2)+2

DO WHILE CNT3 <= CNT1
        AADD(MNCENT2,{F2+2,CNT4,MNCENT1[CNT3]})
        PRIVATE CNT4 := CNT4 + LEN(MNCENT1[CNT3])+2
        PRIVATE CNT3 := CNT3 + 1
ENDDO
RETURN MNCENT2

***************************FUNCION ESTATICA PNTSASE***************************
*ESCRIBE EN EL ARCHIVO .PNT EL SEGMENTO ENTREGADO POR PNTSAVE().
******************************************************************************

STATIC FUNCTION PNTSASE
PARAMETERS E
PRIVATE NAMEDBF := {ALIAS(),RECNO()}
USE (SAVEFILE)
APPEND BLANK
REPLACE APNT1 WITH E[1]
REPLACE BPNT1 WITH E[2]
REPLACE CPNT1 WITH E[3]
REPLACE DPNT1 WITH E[4]
REPLACE EPNT1 WITH SBSTR(E[5],1,860)
REPLACE EPNT2 WITH SBSTR(E[5],861,860)
REPLACE EPNT3 WITH SBSTR(E[5],1721,860)
REPLACE EPNT4 WITH SBSTR(E[5],2581,860)
REPLACE EPNT5 WITH SBSTR(E[5],3441,860)
REPLACE EPNT6 WITH SBSTR(E[5],4301,860)
REPLACE EPNT7 WITH SBSTR(E[5],5161,860)
REPLACE EPNT8 WITH SBSTR(E[5],6021,860)
REPLACE FPNT1 WITH E[6]
REPLACE GPNT1 WITH E[7]
CLOSE DATABASE
IF !EMPTY(NAMEDBF[1])
        USE (NAMEDBF[1])
        GO (NAMEDBF[2])
ENDIF
PRIVATE STIME1 := SEC_TIME()
PRIVATE STIME2 := (((STIME1-STIME)*PNTSLN)/PNTSN1)
EVAL(PNTFC,PNTSN1,{STIME2-(STIME1-STIME),STIME2})
PNTSN1 := PNTSN1 + 1
RETURN NIL

***************************FUNCION ESTATICA PNTSCONT**************************
*RESCATA EL VALOR DEL SEGMENTO PARA PNTCONT().
******************************************************************************

STATIC FUNCTION PNTSCONT

AADD(PNTARRAY,{APNT1,BPNT1,CPNT1,DPNT1,(EPNT1+EPNT2+EPNT3+EPNT4+EPNT5+EPNT6+EPNT7+EPNT8),FPNT1,GPNT1})

PRIVATE STIME1 := SEC_TIME()
PRIVATE STIME2 := (((STIME1-STIME)*PNTSLN)/PNTSN1)
EVAL(PNTFC,{PNTSN1,PNTSLN},{STIME2-(STIME1-STIME),STIME2})
PNTSN1 := PNTSN1 + 1
RETURN NIL

***************************FUNCION ESTATICA ANYTOPNTS*************************
*RESCATA EL VALOR DEL SEGMENTO PARA ANYTOPNT().
******************************************************************************

STATIC FUNCTION ANYTOPNTS
PARAMETERS CLRSCRS

PRIVATE ANYPNTS := ""
        FOR PNTSN3 := 0 TO 42
                IF PNTSN2 <= PNTSLN
                        PRIVATE ANYPNTS := ANYPNTS + PADR(MEMOLINE(ANYPNT,80,PNTSN2,4,.T.),80,CHR(32))
                        PNTSN2 := PNTSN2 + 1
                ELSE
                        EXIT
                ENDIF
        NEXT

PNTSN2 := PNTSN2 - 1
PRIVATE ANYPNTS := CHARMIX(PADR(ANYPNTS,3440,CHR(32)),CHR(COLORTON(CLRSCRS)))

AADD(PNTCONV,{0,0,42,79,ANYPNTS,42,79})

PRIVATE STIME1 := SEC_TIME()
PRIVATE STIME2 := (((STIME1-STIME)*PNTSLN1)/PNTSN1)
EVAL(PNTFC,{PNTSN1,PNTSLN1},{STIME2-(STIME1-STIME),STIME2})
PNTSN1 := PNTSN1 + 1
RETURN NIL

***************************FUNCION ESTATICA PNTTXT****************************
*ESCRIBE EN EL ARCHIVO .TXT EL SEGMENTO ENTREGADO POR PNTTOTXT().
******************************************************************************

STATIC FUNCTION PNTTXT
PARAMETERS E
FWRITE(HNDTXT,CHR(16)+"Segmento Nß: "+ALLTRIM(STR(PNTSN1))+CHR(13)+CHR(10))
FWRITE(HNDTXT,CHR(26)+"Tama§o del Segmento: "+ALLTRIM(STR(E[1]))+","+ALLTRIM(STR(E[2]))+","+ALLTRIM(STR(E[3]))+","+ALLTRIM(STR(E[4]))+CHR(13)+CHR(10))
FWRITE(HNDTXT,CHR(26)+"Tama§o de la Ventana: "+ALLTRIM(STR(E[6]+1))+" Filas; "+ALLTRIM(STR(E[7]+1))+" Columnas."+CHR(13)+CHR(10)+CHR(13)+CHR(10))
FWRITE(HNDTXT,PADC("Inicio del Segmento",80,CHR(95))+CHR(13)+CHR(10))

PRIVATE PNTTXT := LINES(CHARODD(E[5]),(E[4]-E[2])+1)

        FOR PNTSN2 := 1 TO LEN(PNTTXT)
                FWRITE(HNDTXT,RTRIM(PNTTXT[PNTSN2])+CHR(13)+CHR(10))
        NEXT

FWRITE(HNDTXT,PADC("Fin del Segmento",80,CHR(238))+CHR(13)+CHR(10))

PRIVATE STIME1 := SEC_TIME()
PRIVATE STIME2 := (((STIME1-STIME)*PNTSLN)/PNTSN1)
EVAL(PNTFC,PNTSN1,{STIME2-(STIME1-STIME),STIME2})
PNTSN1 := PNTSN1 + 1
RETURN NIL

**************************FUNCION ESTATICA MENFUNC1***************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION MENFUNC1
PRIVATE SETS := {SET(_SET_SCOREBOARD),READEXIT(),SETKEY(9)}
SET SCOREBOARD OFF
READEXIT(.T.)
PRIVATE mfSCOLOR := SETCOLOR()
SETCOLOR(","+FCOLOR4)
SETKEY(9,{|| NULL(KEYSTUFF(24))})
PRIVATE mV1 := PADR(RIGHTDEL(FNAME,"."),255,CHR(32))
        NULL(GETLONG(FROW+17,FCOL+20,"mV1",25),(mV1 := UPPER(CARTRIM(mV1))))
SETCOLOR(mfSCOLOR)
SET(_SET_SCOREBOARD,SETS[1])
READEXIT(SETS[2])
SETKEY(9,SETS[3])
PRIVATE ISMENUa := .F.
IF LASTKEY() = 5 .OR. LASTKEY() = 24
        PRIVATE mf1SCR := SAVESCREEN(FROW+19,FCOL+20,FROW+23,FCOL+46)
        PRIVATE ISMENUa := .T.
        SETKEY(9,{|| KEYSTUFF(4)})
        SETCOLOR(FCOLOR4)
        DISPBOX(FROW+19,FCOL+20,FROW+23,FCOL+46,"⁄ƒø≥Ÿƒ¿≥ ")
        PRIVATE mV1a := ACHOICE(FROW+20,FCOL+21,FROW+22,FCOL+45,aFNAME,,,ASCAN(aFNAME,{|x| x == FNAME}))
        SETKEY(9,SETS[3])
                IF mV1a != 0
                        FNAME := EXOMI(FILE_NAME(aFNAME[mV1a]),__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FILE_NAME(FNAME),".",2)))
                        nFTYPES := IF(ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(EXTRAER(x,".",2))) == ALLTRIM(UPPER(EXTRAER(FNAME,".",2)))}) != 0,ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(EXTRAER(x,".",2))) == ALLTRIM(UPPER(EXTRAER(FNAME,".",2)))}),nFTYPES)
                ENDIF
        RESTSCREEN(FROW+19,FCOL+20,FROW+23,FCOL+46,mf1SCR)
                IF mV1a != 0
                        RETURN && Terminaci¢n Intermedia.
                ENDIF
ENDIF
PRIVATE mf1FPATH := FPATH
DO CASE
        CASE !EMPTY(SOLO_RUTA(mV1))
                FPATH := RIGHTDEL(SOLO_RUTA(mV1),"\") + "\"
                IF !EMPTY(FILE_NAME(mV1))
                        FNAME := EXOMI(FILE_NAME(mV1),__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FILE_NAME(FNAME),".",2)))
                ENDIF
        CASE SBSTR(mV1,2,1) = ":" .AND. LEN(mV1) = 2
                FPATH := SBSTR(mV1,1,1) + ":\" + STUFF(FPATH,1,3,"")
        CASE SBSTR(mV1,2,1) = ":" .AND. SBSTR(mV1,3,1) != "\"
                IF !EMPTY(STUFF(mV1,1,2,""))
                        FNAME := EXOMI(STUFF(mV1,1,2,""),__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FNAME,".",2)))
                ENDIF
                FPATH := SBSTR(mV1,1,1) + ":\" + STUFF(FPATH,1,3,"")
        OTHERWISE
                IF !EMPTY(FILE_NAME(mV1))
                        FNAME := EXOMI(FILE_NAME(mV1),__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FILE_NAME(FNAME),".",2)))
                ENDIF
ENDCASE
IF ISRUTA(FPATH)
        PRIVATE mfDC := {DISKNAME(),"\" + CURDIR()}
        RUN (DRIVE(FPATH) + ":")
        RUN ("CD " + FPATH)
        FPATH := DISKNAME() + ":\" + CURDIR()
        RUN (mfDC[1] + ":")
        RUN ("CD " + mfDC[2])
ELSE
        FPATH := RIGHTDEL(mf1FPATH,"\") + "\"
ENDIF
FPATH := RIGHTDEL(FPATH,"\") + "\"

IF !ISMENUa .AND. LASTKEY() = 13
        FNAME := EXOMI(FNAME,__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FNAME,".",2)))
        IF SBSTR(mV1,LEN(mV1),1) != "\"
                mfEXIT := .T.
        ENDIF
ENDIF
nFTYPES := IF(ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(EXTRAER(x,".",2))) == ALLTRIM(UPPER(EXTRAER(FNAME,".",2)))}) != 0,ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(EXTRAER(x,".",2))) == ALLTRIM(UPPER(EXTRAER(FNAME,".",2)))}),nFTYPES)
RETURN NIL

***************************FUNCION ESTATICA MENFUNC2**************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION MENFUNC2
PRIVATE SETS := {SAVESCREEN(FROW+22,FCOL+20,FROW+26,FCOL+46),SETCOLOR(),SETKEY(9)}
SETKEY(9,{|| KEYSTUFF(4)})
SETCOLOR(FCOLOR4)
DISPBOX(FROW+22,FCOL+20,FROW+26,FCOL+46,"⁄ƒø≥Ÿƒ¿≥ ")
PRIVATE mV2 := ACHOICE(FROW+23,FCOL+21,FROW+25,FCOL+45,FTYPES[2],,,nFTYPES)
        IF mV2 != 0
                nFTYPES := mV2
                IF AT("*",EXTRAER(FTYPES[1][nFTYPES],".",2)) = 0 .AND. AT("<DIR>",ALLTRIM(UPPER(FTYPES[1][nFTYPES]))) = 0
                        FNAME := IF(AT(".",FNAME) != 0,EXTRAER(FNAME,".",1),FNAME) + "." + EXTRAER(FTYPES[1][nFTYPES],".",2)
                ENDIF
        ENDIF
RESTSCREEN(FROW+22,FCOL+20,FROW+26,FCOL+46,SETS[1])
SETCOLOR(SETS[2])
SETKEY(9,SETS[3])
RETURN NIL

***************************FUNCION ESTATICA MENFUNC3**************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION MENFUNC3
PRIVATE SETS := {SAVESCREEN(FROW+2,FCOL+41,FROW+7,FCOL+50),READEXIT(),SETCOLOR(),SETKEY(9)}
READEXIT(.T.)
SETCOLOR(FCOLOR3+","+FCOLOR3)
SETKEY(9,{|| KEYSTUFF(4)})
PRIVATE mV3 := MENBUTTON({{FROW+3,FCOL+42,"Aceptar "},{FROW+6,FCOL+42,"Cancelar"}},FCOLOR1,FCOLOR2,FCOLOR3,,,,,,,1)
READEXIT(SETS[2])
SETCOLOR(SETS[3])
SETKEY(9,SETS[4])
DO CASE
        CASE mV3 = 1 .AND. LASTKEY() = 13
                mfACEPT := .T.
                mfEXIT := .T.
        CASE mV3 = 2 .AND. LASTKEY() = 13 .OR. mV3 = 0
                mfACEPT := .F.
                mfEXIT := .T.
                SETLASTKEY(27)
        OTHERWISE
                mfEXIT := .F.
ENDCASE
RESTSCREEN(FROW+2,FCOL+41,FROW+7,FCOL+50,SETS[1])
RETURN NIL

***************************FUNCION ESTATICA MENFUNC4**************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION MENFUNC4
PRIVATE SETS := {SETCOLOR(),SETKEY(9)}
SETKEY(9,{|| KEYSTUFF(4)})
SETCOLOR(FCOLOR4)
DISPBOX(FROW+5,FCOL+12,FROW+9,FCOL+36,"⁄ƒø≥Ÿƒ¿≥ ")
IF !ISdUNI
PRIVATE mV4 := LEN(dMENUmf4)
ELSE
PRIVATE mV4 := NUMBER_TO(SBSTR(FPATH,1,1))
ENDIF
PRIVATE mV4 := ACHOICE(FROW+6,FCOL+13,FROW+8,FCOL+35,dMENUmf4,,,mV4)
IF mV4 != 0
        IF !ISdUNI
                FPATH := ""
                FOR mfN := 1 TO mV4
                FPATH := FPATH + RIGHTDEL(dMENUmf4[mfN],"\") + "\"
                NEXT
                FPATH := RIGHTDEL(FPATH,"\") + "\"
        ELSE
                FPATH := dMENUmf4[mV4]
        ENDIF
ENDIF
SETCOLOR(SETS[1])
SETKEY(9,SETS[2])
RETURN NIL

***************************FUNCION ESTATICA MENFUNC5**************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION MENFUNC5
IF !EMPTY(dMENUmf5)
        IF LEN(dfMENUmf52) > 0
                PRIVATE mV5 := LEN(dfMENUmf51) + 1
        ELSE
                PRIVATE mV5 := 1
        ENDIF
        KEYSTUFF(1)
        SETCOLOR(FCOLOR3)
        SETCOLOR(FCOLOR4+","+EXTRAER(SETCOLOR(),",",2))
        PRIVATE mV5 := ACHOICE(FROW+9,FCOL+2,FROW+14,FCOL+39,dMENUmf5,,"__mf5MENU",mV5)
        IF mV5 != 0
                DO CASE
                        CASE dfMENUmf5[mV5][5] == "D"
                        FPATH := RIGHTDEL(FPATH,"\") + "\" + dfMENUmf5[mV5][1] + "\"
                        CASE dfMENUmf5[mV5][5] != "D" .AND. LASTKEY() = 13
                        mfEXIT := .T.
                ENDCASE
        ENDIF
ELSE
        PRIVATE mfCUR := SETCURSOR()
        SETCURSOR(0)
        KEYPAUSE(0,.T.,.F.)
        SETCURSOR(mfCUR)
ENDIF
RETURN NIL

***************************FUNCION ESTATICA mf5TYPE***************************
*FUNCION DE MENUFILE().
******************************************************************************

STATIC FUNCTION mf5TYPE
PARAMETERS df1, df2
IF df2 == "D"
        PRIVATE ftASa := ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(x)) == "<DIR>"})
        IF ftASa == 0
                RETURN PADR("<DIR>",12," ")
        ELSE
                RETURN PADR(FTYPES[2][ftASa],12," ")
        ENDIF
ELSE
        IF !EMPTY(EXTRAER(df1,".",2))
                PRIVATE ftASb := ASCAN(FTYPES[1],{|x| ALLTRIM(UPPER(EXTRAER(x,".",2))) == ALLTRIM(UPPER(EXTRAER(df1,".",2)))})
        ELSE
                PRIVATE ftaSb := 0
        ENDIF
        IF ftASb == 0
                RETURN PADR(EXTRAER(df1,".",2)+IF(!EMPTY(EXTRAER(df1,".",2))," ","")+"Archivo",12," ")
        ELSE
                RETURN PADR(FTYPES[2][ftASb],12," ")
        ENDIF
ENDIF
RETURN NIL

***************************FUNCION ESTATICA mf5MENU***************************
*FUNCION DE MENUFILE().
******************************************************************************

FUNCTION __mf5MENU
PARAMETERS A, B, C
IF dfMENUmf5[B][5] != "D"
        FNAME := EXOMI(dfMENUmf5[B][1],__mfEXNAME(FTYPES[1][nFTYPES],EXTRAER(FNAME,".",2)))
        @FROW+17,FCOL+20 SAY PADR(FNAME,25," ")
ENDIF
IF LASTKEY() = 9
        SETLASTKEY(4)
ENDIF
DO CASE
        CASE ISALPHA(CHR(LASTKEY()))
        KEYSTUFF(1)
        RETURN 3
        CASE LASTKEY() = 13
        RETURN 1
        CASE LASTKEY() = 27 .OR. LASTKEY() = 19 .OR. LASTKEY() = 4
        RETURN 0
        CASE LASTKEY() = -4
                PRIVATE SCOLOR := SETCOLOR()
                SETCOLOR(FCOLOR3+","+FCOLOR3)
                PRIVATE mf5MENUscr := SAVESCREEN(FROW+5,FCOL+1,FROW+7,FCOL+40)
                PRIVATE mf5MENU := MENBUTTON({{FROW+6,FCOL+2,"Nombre      "},{FROW+6,FCOL+16,"Tipo        "},{FROW+6,FCOL+30,"Modificado"}},FCOLOR1,FCOLOR2,FCOLOR3,,,bORGANI[3],2)
                RESTSCREEN(FROW+5,FCOL+1,FROW+7,FCOL+40,mf5MENUscr)
                SETCOLOR(SCOLOR)
                DO CASE
                        CASE mf5MENU = 1
                                bORGANI[1] := {|X,Y| X[1] < Y[1]}
                                bORGANI[2] := {|X,Y| X[1] < Y[1]}
                                bORGANI[3] := mf5MENU
                        CASE mf5MENU = 2
                                bORGANI[2] := {|X,Y| X[6] < Y[6]}
                                bORGANI[3] := mf5MENU
                        CASE mf5MENU = 3
                                bORGANI[1] := {|X,Y| X[3] < Y[3]}
                                bORGANI[2] := {|X,Y| X[3] < Y[3]}
                                bORGANI[3] := mf5MENU
                ENDCASE
                IF mf5MENU != 0
                        RETURN 0
                ELSE
                        RETURN 2
                ENDIF

        OTHERWISE
        RETURN 2
ENDCASE
RETURN NIL

***************************FUNCION ESTATICA mfEXNAME**************************
*FUNCION DE MENUFILE().
******************************************************************************

FUNCTION __mfEXNAME
PARAMETERS EXN1, EXN2
RETURN IF(EMPTY(AT("*",EXN1)) .AND. EMPTY(AT("<DIR>",UPPER(EXN1))), EXN1, EXN2)
